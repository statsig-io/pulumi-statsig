// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package statsig

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/statsig-io/pulumi-statsig/sdk/go/statsig/internal"
)

// This resource allows you to configure experiments for your Statsig project.
//
// To learn more about experiments, see [Experiments Documentation](https://docs.statsig.com/experiments-plus/)
//
// To learn more about the API powering this resource, see [Experiments API Documentation](https://docs.statsig.com/console-api/experiments)
type Experiment struct {
	pulumi.CustomResourceState

	// Percent of layer allocated to this experiment
	Allocation pulumi.Float64Output `pulumi:"allocation"`
	// Warehouse Native Only - Allocation duration in days
	AllocationDuration pulumi.IntOutput `pulumi:"allocationDuration"`
	// Warehouse Native only - end time for analysis only experiments
	AnalysisEndTime pulumi.StringOutput `pulumi:"analysisEndTime"`
	// The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
	AnalyticsType pulumi.StringOutput `pulumi:"analyticsType"`
	// Name of the source experiment for assignment
	AssignmentSourceExperimentName pulumi.StringOutput `pulumi:"assignmentSourceExperimentName"`
	// Source name of the assignment
	AssignmentSourceName pulumi.StringOutput `pulumi:"assignmentSourceName"`
	// Is Benjamini-Hochberg procedure applied per metric?
	BenjaminiHochbergPerMetric pulumi.BoolOutput `pulumi:"benjaminiHochbergPerMetric"`
	// Is Benjamini-Hochberg procedure applied per variant?
	BenjaminiHochbergPerVariant pulumi.BoolOutput `pulumi:"benjaminiHochbergPerVariant"`
	// Is Benjamini-Hochberg procedure applied for primary metrics only?
	BenjaminiPrimaryMetricsOnly pulumi.BoolOutput `pulumi:"benjaminiPrimaryMetricsOnly"`
	// Is Bonferroni correction applied per variant?
	BonferroniCorrection pulumi.BoolOutput `pulumi:"bonferroniCorrection"`
	// Is Bonferroni correction applied per metric?
	BonferroniCorrectionPerMetric pulumi.BoolOutput `pulumi:"bonferroniCorrectionPerMetric"`
	// Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
	CohortWaitUntilEndToInclude pulumi.BoolOutput `pulumi:"cohortWaitUntilEndToInclude"`
	// Warehouse Native Only - Cohorted analysis duration in days
	CohortedAnalysisDuration pulumi.IntOutput `pulumi:"cohortedAnalysisDuration"`
	// Warehouse Native Only - Allow cohort metrics to mature after experiment end
	CohortedMetricsMatureAfterEnd pulumi.BoolOutput `pulumi:"cohortedMetricsMatureAfterEnd"`
	// Optional control group ID
	ControlGroupId pulumi.StringOutput `pulumi:"controlGroupId"`
	// The email of the creator of this experiment
	CreatorEmail pulumi.StringOutput `pulumi:"creatorEmail"`
	// The Statsig ID of the creator of this experiment
	CreatorId pulumi.StringOutput `pulumi:"creatorId"`
	// Default error margin used for results
	DefaultConfidenceInterval pulumi.StringOutput `pulumi:"defaultConfidenceInterval"`
	// A description of the new experiment
	Description pulumi.StringOutput `pulumi:"description"`
	// How long the experiment is expected to last in days
	Duration pulumi.IntOutput `pulumi:"duration"`
	// Fixed analysis duration in days
	FixedAnalysisDuration pulumi.IntOutput `pulumi:"fixedAnalysisDuration"`
	// The test groups for your experiment
	Groups ExperimentGroupArrayOutput `pulumi:"groups"`
	// A statement that will be tested by this experiment
	Hypothesis pulumi.StringOutput `pulumi:"hypothesis"`
	// The idType the experiment will be performed on
	IdType pulumi.StringOutput `pulumi:"idType"`
	// For Warehouse Native
	IsAnalysisOnly pulumi.BoolOutput `pulumi:"isAnalysisOnly"`
	// ID of the launched group, null otherwise
	LaunchedGroupId pulumi.StringOutput `pulumi:"launchedGroupId"`
	// Which layer to place the experiment into.
	LayerId pulumi.StringOutput `pulumi:"layerId"`
	// Links to relevant documentation or resources
	Links ExperimentLinkArrayOutput `pulumi:"links"`
	// The name of the new experiment
	Name pulumi.StringOutput `pulumi:"name"`
	// Primary metric tags for the experiment
	PrimaryMetricTags pulumi.StringArrayOutput `pulumi:"primaryMetricTags"`
	// Main metrics needed to evaluate your hypothesis
	PrimaryMetrics ExperimentPrimaryMetricArrayOutput `pulumi:"primaryMetrics"`
	// Warehouse Native only - UTC hour at which to run scheduled pulse loads
	ScheduledReloadHour pulumi.IntOutput `pulumi:"scheduledReloadHour"`
	// Warehouse Native only - reload type for scheduled reloads
	ScheduledReloadType pulumi.StringOutput `pulumi:"scheduledReloadType"`
	// The secondary ID type for the experiment used in WHN for ID resolution
	SecondaryIdtype pulumi.StringOutput `pulumi:"secondaryIdtype"`
	// Secondary metric tags for the experiment
	SecondaryMetricTags pulumi.StringArrayOutput `pulumi:"secondaryMetricTags"`
	// Additional metrics to monitor that might impact the analysis or final decision of the experiment
	SecondaryMetrics ExperimentSecondaryMetricArrayOutput `pulumi:"secondaryMetrics"`
	// Apply sequential testing?
	SequentialTesting pulumi.BoolOutput `pulumi:"sequentialTesting"`
	// The current status of the experiment
	Status pulumi.StringOutput `pulumi:"status"`
	// Tags associated with the experiment
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// Target apps assigned to this experiment
	TargetApps pulumi.StringArrayOutput `pulumi:"targetApps"`
	// Target exposures for the experiment
	TargetExposures pulumi.IntOutput `pulumi:"targetExposures"`
	// Restrict your experiment to users passing the selected feature gate
	TargetingGateId pulumi.StringOutput `pulumi:"targetingGateId"`
	// Enterprise only
	Team pulumi.StringOutput `pulumi:"team"`
}

// NewExperiment registers a new resource with the given unique name, arguments, and options.
func NewExperiment(ctx *pulumi.Context,
	name string, args *ExperimentArgs, opts ...pulumi.ResourceOption) (*Experiment, error) {
	if args == nil {
		args = &ExperimentArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Experiment
	err := ctx.RegisterResource("statsig:index/experiment:Experiment", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetExperiment gets an existing Experiment resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetExperiment(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ExperimentState, opts ...pulumi.ResourceOption) (*Experiment, error) {
	var resource Experiment
	err := ctx.ReadResource("statsig:index/experiment:Experiment", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Experiment resources.
type experimentState struct {
	// Percent of layer allocated to this experiment
	Allocation *float64 `pulumi:"allocation"`
	// Warehouse Native Only - Allocation duration in days
	AllocationDuration *int `pulumi:"allocationDuration"`
	// Warehouse Native only - end time for analysis only experiments
	AnalysisEndTime *string `pulumi:"analysisEndTime"`
	// The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
	AnalyticsType *string `pulumi:"analyticsType"`
	// Name of the source experiment for assignment
	AssignmentSourceExperimentName *string `pulumi:"assignmentSourceExperimentName"`
	// Source name of the assignment
	AssignmentSourceName *string `pulumi:"assignmentSourceName"`
	// Is Benjamini-Hochberg procedure applied per metric?
	BenjaminiHochbergPerMetric *bool `pulumi:"benjaminiHochbergPerMetric"`
	// Is Benjamini-Hochberg procedure applied per variant?
	BenjaminiHochbergPerVariant *bool `pulumi:"benjaminiHochbergPerVariant"`
	// Is Benjamini-Hochberg procedure applied for primary metrics only?
	BenjaminiPrimaryMetricsOnly *bool `pulumi:"benjaminiPrimaryMetricsOnly"`
	// Is Bonferroni correction applied per variant?
	BonferroniCorrection *bool `pulumi:"bonferroniCorrection"`
	// Is Bonferroni correction applied per metric?
	BonferroniCorrectionPerMetric *bool `pulumi:"bonferroniCorrectionPerMetric"`
	// Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
	CohortWaitUntilEndToInclude *bool `pulumi:"cohortWaitUntilEndToInclude"`
	// Warehouse Native Only - Cohorted analysis duration in days
	CohortedAnalysisDuration *int `pulumi:"cohortedAnalysisDuration"`
	// Warehouse Native Only - Allow cohort metrics to mature after experiment end
	CohortedMetricsMatureAfterEnd *bool `pulumi:"cohortedMetricsMatureAfterEnd"`
	// Optional control group ID
	ControlGroupId *string `pulumi:"controlGroupId"`
	// The email of the creator of this experiment
	CreatorEmail *string `pulumi:"creatorEmail"`
	// The Statsig ID of the creator of this experiment
	CreatorId *string `pulumi:"creatorId"`
	// Default error margin used for results
	DefaultConfidenceInterval *string `pulumi:"defaultConfidenceInterval"`
	// A description of the new experiment
	Description *string `pulumi:"description"`
	// How long the experiment is expected to last in days
	Duration *int `pulumi:"duration"`
	// Fixed analysis duration in days
	FixedAnalysisDuration *int `pulumi:"fixedAnalysisDuration"`
	// The test groups for your experiment
	Groups []ExperimentGroup `pulumi:"groups"`
	// A statement that will be tested by this experiment
	Hypothesis *string `pulumi:"hypothesis"`
	// The idType the experiment will be performed on
	IdType *string `pulumi:"idType"`
	// For Warehouse Native
	IsAnalysisOnly *bool `pulumi:"isAnalysisOnly"`
	// ID of the launched group, null otherwise
	LaunchedGroupId *string `pulumi:"launchedGroupId"`
	// Which layer to place the experiment into.
	LayerId *string `pulumi:"layerId"`
	// Links to relevant documentation or resources
	Links []ExperimentLink `pulumi:"links"`
	// The name of the new experiment
	Name *string `pulumi:"name"`
	// Primary metric tags for the experiment
	PrimaryMetricTags []string `pulumi:"primaryMetricTags"`
	// Main metrics needed to evaluate your hypothesis
	PrimaryMetrics []ExperimentPrimaryMetric `pulumi:"primaryMetrics"`
	// Warehouse Native only - UTC hour at which to run scheduled pulse loads
	ScheduledReloadHour *int `pulumi:"scheduledReloadHour"`
	// Warehouse Native only - reload type for scheduled reloads
	ScheduledReloadType *string `pulumi:"scheduledReloadType"`
	// The secondary ID type for the experiment used in WHN for ID resolution
	SecondaryIdtype *string `pulumi:"secondaryIdtype"`
	// Secondary metric tags for the experiment
	SecondaryMetricTags []string `pulumi:"secondaryMetricTags"`
	// Additional metrics to monitor that might impact the analysis or final decision of the experiment
	SecondaryMetrics []ExperimentSecondaryMetric `pulumi:"secondaryMetrics"`
	// Apply sequential testing?
	SequentialTesting *bool `pulumi:"sequentialTesting"`
	// The current status of the experiment
	Status *string `pulumi:"status"`
	// Tags associated with the experiment
	Tags []string `pulumi:"tags"`
	// Target apps assigned to this experiment
	TargetApps []string `pulumi:"targetApps"`
	// Target exposures for the experiment
	TargetExposures *int `pulumi:"targetExposures"`
	// Restrict your experiment to users passing the selected feature gate
	TargetingGateId *string `pulumi:"targetingGateId"`
	// Enterprise only
	Team *string `pulumi:"team"`
}

type ExperimentState struct {
	// Percent of layer allocated to this experiment
	Allocation pulumi.Float64PtrInput
	// Warehouse Native Only - Allocation duration in days
	AllocationDuration pulumi.IntPtrInput
	// Warehouse Native only - end time for analysis only experiments
	AnalysisEndTime pulumi.StringPtrInput
	// The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
	AnalyticsType pulumi.StringPtrInput
	// Name of the source experiment for assignment
	AssignmentSourceExperimentName pulumi.StringPtrInput
	// Source name of the assignment
	AssignmentSourceName pulumi.StringPtrInput
	// Is Benjamini-Hochberg procedure applied per metric?
	BenjaminiHochbergPerMetric pulumi.BoolPtrInput
	// Is Benjamini-Hochberg procedure applied per variant?
	BenjaminiHochbergPerVariant pulumi.BoolPtrInput
	// Is Benjamini-Hochberg procedure applied for primary metrics only?
	BenjaminiPrimaryMetricsOnly pulumi.BoolPtrInput
	// Is Bonferroni correction applied per variant?
	BonferroniCorrection pulumi.BoolPtrInput
	// Is Bonferroni correction applied per metric?
	BonferroniCorrectionPerMetric pulumi.BoolPtrInput
	// Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
	CohortWaitUntilEndToInclude pulumi.BoolPtrInput
	// Warehouse Native Only - Cohorted analysis duration in days
	CohortedAnalysisDuration pulumi.IntPtrInput
	// Warehouse Native Only - Allow cohort metrics to mature after experiment end
	CohortedMetricsMatureAfterEnd pulumi.BoolPtrInput
	// Optional control group ID
	ControlGroupId pulumi.StringPtrInput
	// The email of the creator of this experiment
	CreatorEmail pulumi.StringPtrInput
	// The Statsig ID of the creator of this experiment
	CreatorId pulumi.StringPtrInput
	// Default error margin used for results
	DefaultConfidenceInterval pulumi.StringPtrInput
	// A description of the new experiment
	Description pulumi.StringPtrInput
	// How long the experiment is expected to last in days
	Duration pulumi.IntPtrInput
	// Fixed analysis duration in days
	FixedAnalysisDuration pulumi.IntPtrInput
	// The test groups for your experiment
	Groups ExperimentGroupArrayInput
	// A statement that will be tested by this experiment
	Hypothesis pulumi.StringPtrInput
	// The idType the experiment will be performed on
	IdType pulumi.StringPtrInput
	// For Warehouse Native
	IsAnalysisOnly pulumi.BoolPtrInput
	// ID of the launched group, null otherwise
	LaunchedGroupId pulumi.StringPtrInput
	// Which layer to place the experiment into.
	LayerId pulumi.StringPtrInput
	// Links to relevant documentation or resources
	Links ExperimentLinkArrayInput
	// The name of the new experiment
	Name pulumi.StringPtrInput
	// Primary metric tags for the experiment
	PrimaryMetricTags pulumi.StringArrayInput
	// Main metrics needed to evaluate your hypothesis
	PrimaryMetrics ExperimentPrimaryMetricArrayInput
	// Warehouse Native only - UTC hour at which to run scheduled pulse loads
	ScheduledReloadHour pulumi.IntPtrInput
	// Warehouse Native only - reload type for scheduled reloads
	ScheduledReloadType pulumi.StringPtrInput
	// The secondary ID type for the experiment used in WHN for ID resolution
	SecondaryIdtype pulumi.StringPtrInput
	// Secondary metric tags for the experiment
	SecondaryMetricTags pulumi.StringArrayInput
	// Additional metrics to monitor that might impact the analysis or final decision of the experiment
	SecondaryMetrics ExperimentSecondaryMetricArrayInput
	// Apply sequential testing?
	SequentialTesting pulumi.BoolPtrInput
	// The current status of the experiment
	Status pulumi.StringPtrInput
	// Tags associated with the experiment
	Tags pulumi.StringArrayInput
	// Target apps assigned to this experiment
	TargetApps pulumi.StringArrayInput
	// Target exposures for the experiment
	TargetExposures pulumi.IntPtrInput
	// Restrict your experiment to users passing the selected feature gate
	TargetingGateId pulumi.StringPtrInput
	// Enterprise only
	Team pulumi.StringPtrInput
}

func (ExperimentState) ElementType() reflect.Type {
	return reflect.TypeOf((*experimentState)(nil)).Elem()
}

type experimentArgs struct {
	// Percent of layer allocated to this experiment
	Allocation *float64 `pulumi:"allocation"`
	// Warehouse Native Only - Allocation duration in days
	AllocationDuration *int `pulumi:"allocationDuration"`
	// Warehouse Native only - end time for analysis only experiments
	AnalysisEndTime *string `pulumi:"analysisEndTime"`
	// The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
	AnalyticsType *string `pulumi:"analyticsType"`
	// Name of the source experiment for assignment
	AssignmentSourceExperimentName *string `pulumi:"assignmentSourceExperimentName"`
	// Source name of the assignment
	AssignmentSourceName *string `pulumi:"assignmentSourceName"`
	// Is Benjamini-Hochberg procedure applied per metric?
	BenjaminiHochbergPerMetric *bool `pulumi:"benjaminiHochbergPerMetric"`
	// Is Benjamini-Hochberg procedure applied per variant?
	BenjaminiHochbergPerVariant *bool `pulumi:"benjaminiHochbergPerVariant"`
	// Is Benjamini-Hochberg procedure applied for primary metrics only?
	BenjaminiPrimaryMetricsOnly *bool `pulumi:"benjaminiPrimaryMetricsOnly"`
	// Is Bonferroni correction applied per variant?
	BonferroniCorrection *bool `pulumi:"bonferroniCorrection"`
	// Is Bonferroni correction applied per metric?
	BonferroniCorrectionPerMetric *bool `pulumi:"bonferroniCorrectionPerMetric"`
	// Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
	CohortWaitUntilEndToInclude *bool `pulumi:"cohortWaitUntilEndToInclude"`
	// Warehouse Native Only - Cohorted analysis duration in days
	CohortedAnalysisDuration *int `pulumi:"cohortedAnalysisDuration"`
	// Warehouse Native Only - Allow cohort metrics to mature after experiment end
	CohortedMetricsMatureAfterEnd *bool `pulumi:"cohortedMetricsMatureAfterEnd"`
	// Optional control group ID
	ControlGroupId *string `pulumi:"controlGroupId"`
	// The email of the creator of this experiment
	CreatorEmail *string `pulumi:"creatorEmail"`
	// The Statsig ID of the creator of this experiment
	CreatorId *string `pulumi:"creatorId"`
	// Default error margin used for results
	DefaultConfidenceInterval *string `pulumi:"defaultConfidenceInterval"`
	// A description of the new experiment
	Description *string `pulumi:"description"`
	// How long the experiment is expected to last in days
	Duration *int `pulumi:"duration"`
	// Fixed analysis duration in days
	FixedAnalysisDuration *int `pulumi:"fixedAnalysisDuration"`
	// The test groups for your experiment
	Groups []ExperimentGroup `pulumi:"groups"`
	// A statement that will be tested by this experiment
	Hypothesis *string `pulumi:"hypothesis"`
	// The idType the experiment will be performed on
	IdType *string `pulumi:"idType"`
	// For Warehouse Native
	IsAnalysisOnly *bool `pulumi:"isAnalysisOnly"`
	// ID of the launched group, null otherwise
	LaunchedGroupId *string `pulumi:"launchedGroupId"`
	// Which layer to place the experiment into.
	LayerId *string `pulumi:"layerId"`
	// Links to relevant documentation or resources
	Links []ExperimentLink `pulumi:"links"`
	// The name of the new experiment
	Name *string `pulumi:"name"`
	// Primary metric tags for the experiment
	PrimaryMetricTags []string `pulumi:"primaryMetricTags"`
	// Main metrics needed to evaluate your hypothesis
	PrimaryMetrics []ExperimentPrimaryMetric `pulumi:"primaryMetrics"`
	// Warehouse Native only - UTC hour at which to run scheduled pulse loads
	ScheduledReloadHour *int `pulumi:"scheduledReloadHour"`
	// Warehouse Native only - reload type for scheduled reloads
	ScheduledReloadType *string `pulumi:"scheduledReloadType"`
	// The secondary ID type for the experiment used in WHN for ID resolution
	SecondaryIdtype *string `pulumi:"secondaryIdtype"`
	// Secondary metric tags for the experiment
	SecondaryMetricTags []string `pulumi:"secondaryMetricTags"`
	// Additional metrics to monitor that might impact the analysis or final decision of the experiment
	SecondaryMetrics []ExperimentSecondaryMetric `pulumi:"secondaryMetrics"`
	// Apply sequential testing?
	SequentialTesting *bool `pulumi:"sequentialTesting"`
	// The current status of the experiment
	Status *string `pulumi:"status"`
	// Tags associated with the experiment
	Tags []string `pulumi:"tags"`
	// Target apps assigned to this experiment
	TargetApps []string `pulumi:"targetApps"`
	// Target exposures for the experiment
	TargetExposures *int `pulumi:"targetExposures"`
	// Restrict your experiment to users passing the selected feature gate
	TargetingGateId *string `pulumi:"targetingGateId"`
	// Enterprise only
	Team *string `pulumi:"team"`
}

// The set of arguments for constructing a Experiment resource.
type ExperimentArgs struct {
	// Percent of layer allocated to this experiment
	Allocation pulumi.Float64PtrInput
	// Warehouse Native Only - Allocation duration in days
	AllocationDuration pulumi.IntPtrInput
	// Warehouse Native only - end time for analysis only experiments
	AnalysisEndTime pulumi.StringPtrInput
	// The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
	AnalyticsType pulumi.StringPtrInput
	// Name of the source experiment for assignment
	AssignmentSourceExperimentName pulumi.StringPtrInput
	// Source name of the assignment
	AssignmentSourceName pulumi.StringPtrInput
	// Is Benjamini-Hochberg procedure applied per metric?
	BenjaminiHochbergPerMetric pulumi.BoolPtrInput
	// Is Benjamini-Hochberg procedure applied per variant?
	BenjaminiHochbergPerVariant pulumi.BoolPtrInput
	// Is Benjamini-Hochberg procedure applied for primary metrics only?
	BenjaminiPrimaryMetricsOnly pulumi.BoolPtrInput
	// Is Bonferroni correction applied per variant?
	BonferroniCorrection pulumi.BoolPtrInput
	// Is Bonferroni correction applied per metric?
	BonferroniCorrectionPerMetric pulumi.BoolPtrInput
	// Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
	CohortWaitUntilEndToInclude pulumi.BoolPtrInput
	// Warehouse Native Only - Cohorted analysis duration in days
	CohortedAnalysisDuration pulumi.IntPtrInput
	// Warehouse Native Only - Allow cohort metrics to mature after experiment end
	CohortedMetricsMatureAfterEnd pulumi.BoolPtrInput
	// Optional control group ID
	ControlGroupId pulumi.StringPtrInput
	// The email of the creator of this experiment
	CreatorEmail pulumi.StringPtrInput
	// The Statsig ID of the creator of this experiment
	CreatorId pulumi.StringPtrInput
	// Default error margin used for results
	DefaultConfidenceInterval pulumi.StringPtrInput
	// A description of the new experiment
	Description pulumi.StringPtrInput
	// How long the experiment is expected to last in days
	Duration pulumi.IntPtrInput
	// Fixed analysis duration in days
	FixedAnalysisDuration pulumi.IntPtrInput
	// The test groups for your experiment
	Groups ExperimentGroupArrayInput
	// A statement that will be tested by this experiment
	Hypothesis pulumi.StringPtrInput
	// The idType the experiment will be performed on
	IdType pulumi.StringPtrInput
	// For Warehouse Native
	IsAnalysisOnly pulumi.BoolPtrInput
	// ID of the launched group, null otherwise
	LaunchedGroupId pulumi.StringPtrInput
	// Which layer to place the experiment into.
	LayerId pulumi.StringPtrInput
	// Links to relevant documentation or resources
	Links ExperimentLinkArrayInput
	// The name of the new experiment
	Name pulumi.StringPtrInput
	// Primary metric tags for the experiment
	PrimaryMetricTags pulumi.StringArrayInput
	// Main metrics needed to evaluate your hypothesis
	PrimaryMetrics ExperimentPrimaryMetricArrayInput
	// Warehouse Native only - UTC hour at which to run scheduled pulse loads
	ScheduledReloadHour pulumi.IntPtrInput
	// Warehouse Native only - reload type for scheduled reloads
	ScheduledReloadType pulumi.StringPtrInput
	// The secondary ID type for the experiment used in WHN for ID resolution
	SecondaryIdtype pulumi.StringPtrInput
	// Secondary metric tags for the experiment
	SecondaryMetricTags pulumi.StringArrayInput
	// Additional metrics to monitor that might impact the analysis or final decision of the experiment
	SecondaryMetrics ExperimentSecondaryMetricArrayInput
	// Apply sequential testing?
	SequentialTesting pulumi.BoolPtrInput
	// The current status of the experiment
	Status pulumi.StringPtrInput
	// Tags associated with the experiment
	Tags pulumi.StringArrayInput
	// Target apps assigned to this experiment
	TargetApps pulumi.StringArrayInput
	// Target exposures for the experiment
	TargetExposures pulumi.IntPtrInput
	// Restrict your experiment to users passing the selected feature gate
	TargetingGateId pulumi.StringPtrInput
	// Enterprise only
	Team pulumi.StringPtrInput
}

func (ExperimentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*experimentArgs)(nil)).Elem()
}

type ExperimentInput interface {
	pulumi.Input

	ToExperimentOutput() ExperimentOutput
	ToExperimentOutputWithContext(ctx context.Context) ExperimentOutput
}

func (*Experiment) ElementType() reflect.Type {
	return reflect.TypeOf((**Experiment)(nil)).Elem()
}

func (i *Experiment) ToExperimentOutput() ExperimentOutput {
	return i.ToExperimentOutputWithContext(context.Background())
}

func (i *Experiment) ToExperimentOutputWithContext(ctx context.Context) ExperimentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExperimentOutput)
}

// ExperimentArrayInput is an input type that accepts ExperimentArray and ExperimentArrayOutput values.
// You can construct a concrete instance of `ExperimentArrayInput` via:
//
//	ExperimentArray{ ExperimentArgs{...} }
type ExperimentArrayInput interface {
	pulumi.Input

	ToExperimentArrayOutput() ExperimentArrayOutput
	ToExperimentArrayOutputWithContext(context.Context) ExperimentArrayOutput
}

type ExperimentArray []ExperimentInput

func (ExperimentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Experiment)(nil)).Elem()
}

func (i ExperimentArray) ToExperimentArrayOutput() ExperimentArrayOutput {
	return i.ToExperimentArrayOutputWithContext(context.Background())
}

func (i ExperimentArray) ToExperimentArrayOutputWithContext(ctx context.Context) ExperimentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExperimentArrayOutput)
}

// ExperimentMapInput is an input type that accepts ExperimentMap and ExperimentMapOutput values.
// You can construct a concrete instance of `ExperimentMapInput` via:
//
//	ExperimentMap{ "key": ExperimentArgs{...} }
type ExperimentMapInput interface {
	pulumi.Input

	ToExperimentMapOutput() ExperimentMapOutput
	ToExperimentMapOutputWithContext(context.Context) ExperimentMapOutput
}

type ExperimentMap map[string]ExperimentInput

func (ExperimentMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Experiment)(nil)).Elem()
}

func (i ExperimentMap) ToExperimentMapOutput() ExperimentMapOutput {
	return i.ToExperimentMapOutputWithContext(context.Background())
}

func (i ExperimentMap) ToExperimentMapOutputWithContext(ctx context.Context) ExperimentMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExperimentMapOutput)
}

type ExperimentOutput struct{ *pulumi.OutputState }

func (ExperimentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Experiment)(nil)).Elem()
}

func (o ExperimentOutput) ToExperimentOutput() ExperimentOutput {
	return o
}

func (o ExperimentOutput) ToExperimentOutputWithContext(ctx context.Context) ExperimentOutput {
	return o
}

// Percent of layer allocated to this experiment
func (o ExperimentOutput) Allocation() pulumi.Float64Output {
	return o.ApplyT(func(v *Experiment) pulumi.Float64Output { return v.Allocation }).(pulumi.Float64Output)
}

// Warehouse Native Only - Allocation duration in days
func (o ExperimentOutput) AllocationDuration() pulumi.IntOutput {
	return o.ApplyT(func(v *Experiment) pulumi.IntOutput { return v.AllocationDuration }).(pulumi.IntOutput)
}

// Warehouse Native only - end time for analysis only experiments
func (o ExperimentOutput) AnalysisEndTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.AnalysisEndTime }).(pulumi.StringOutput)
}

// The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
func (o ExperimentOutput) AnalyticsType() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.AnalyticsType }).(pulumi.StringOutput)
}

// Name of the source experiment for assignment
func (o ExperimentOutput) AssignmentSourceExperimentName() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.AssignmentSourceExperimentName }).(pulumi.StringOutput)
}

// Source name of the assignment
func (o ExperimentOutput) AssignmentSourceName() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.AssignmentSourceName }).(pulumi.StringOutput)
}

// Is Benjamini-Hochberg procedure applied per metric?
func (o ExperimentOutput) BenjaminiHochbergPerMetric() pulumi.BoolOutput {
	return o.ApplyT(func(v *Experiment) pulumi.BoolOutput { return v.BenjaminiHochbergPerMetric }).(pulumi.BoolOutput)
}

// Is Benjamini-Hochberg procedure applied per variant?
func (o ExperimentOutput) BenjaminiHochbergPerVariant() pulumi.BoolOutput {
	return o.ApplyT(func(v *Experiment) pulumi.BoolOutput { return v.BenjaminiHochbergPerVariant }).(pulumi.BoolOutput)
}

// Is Benjamini-Hochberg procedure applied for primary metrics only?
func (o ExperimentOutput) BenjaminiPrimaryMetricsOnly() pulumi.BoolOutput {
	return o.ApplyT(func(v *Experiment) pulumi.BoolOutput { return v.BenjaminiPrimaryMetricsOnly }).(pulumi.BoolOutput)
}

// Is Bonferroni correction applied per variant?
func (o ExperimentOutput) BonferroniCorrection() pulumi.BoolOutput {
	return o.ApplyT(func(v *Experiment) pulumi.BoolOutput { return v.BonferroniCorrection }).(pulumi.BoolOutput)
}

// Is Bonferroni correction applied per metric?
func (o ExperimentOutput) BonferroniCorrectionPerMetric() pulumi.BoolOutput {
	return o.ApplyT(func(v *Experiment) pulumi.BoolOutput { return v.BonferroniCorrectionPerMetric }).(pulumi.BoolOutput)
}

// Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
func (o ExperimentOutput) CohortWaitUntilEndToInclude() pulumi.BoolOutput {
	return o.ApplyT(func(v *Experiment) pulumi.BoolOutput { return v.CohortWaitUntilEndToInclude }).(pulumi.BoolOutput)
}

// Warehouse Native Only - Cohorted analysis duration in days
func (o ExperimentOutput) CohortedAnalysisDuration() pulumi.IntOutput {
	return o.ApplyT(func(v *Experiment) pulumi.IntOutput { return v.CohortedAnalysisDuration }).(pulumi.IntOutput)
}

// Warehouse Native Only - Allow cohort metrics to mature after experiment end
func (o ExperimentOutput) CohortedMetricsMatureAfterEnd() pulumi.BoolOutput {
	return o.ApplyT(func(v *Experiment) pulumi.BoolOutput { return v.CohortedMetricsMatureAfterEnd }).(pulumi.BoolOutput)
}

// Optional control group ID
func (o ExperimentOutput) ControlGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.ControlGroupId }).(pulumi.StringOutput)
}

// The email of the creator of this experiment
func (o ExperimentOutput) CreatorEmail() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.CreatorEmail }).(pulumi.StringOutput)
}

// The Statsig ID of the creator of this experiment
func (o ExperimentOutput) CreatorId() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.CreatorId }).(pulumi.StringOutput)
}

// Default error margin used for results
func (o ExperimentOutput) DefaultConfidenceInterval() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.DefaultConfidenceInterval }).(pulumi.StringOutput)
}

// A description of the new experiment
func (o ExperimentOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.Description }).(pulumi.StringOutput)
}

// How long the experiment is expected to last in days
func (o ExperimentOutput) Duration() pulumi.IntOutput {
	return o.ApplyT(func(v *Experiment) pulumi.IntOutput { return v.Duration }).(pulumi.IntOutput)
}

// Fixed analysis duration in days
func (o ExperimentOutput) FixedAnalysisDuration() pulumi.IntOutput {
	return o.ApplyT(func(v *Experiment) pulumi.IntOutput { return v.FixedAnalysisDuration }).(pulumi.IntOutput)
}

// The test groups for your experiment
func (o ExperimentOutput) Groups() ExperimentGroupArrayOutput {
	return o.ApplyT(func(v *Experiment) ExperimentGroupArrayOutput { return v.Groups }).(ExperimentGroupArrayOutput)
}

// A statement that will be tested by this experiment
func (o ExperimentOutput) Hypothesis() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.Hypothesis }).(pulumi.StringOutput)
}

// The idType the experiment will be performed on
func (o ExperimentOutput) IdType() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.IdType }).(pulumi.StringOutput)
}

// For Warehouse Native
func (o ExperimentOutput) IsAnalysisOnly() pulumi.BoolOutput {
	return o.ApplyT(func(v *Experiment) pulumi.BoolOutput { return v.IsAnalysisOnly }).(pulumi.BoolOutput)
}

// ID of the launched group, null otherwise
func (o ExperimentOutput) LaunchedGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.LaunchedGroupId }).(pulumi.StringOutput)
}

// Which layer to place the experiment into.
func (o ExperimentOutput) LayerId() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.LayerId }).(pulumi.StringOutput)
}

// Links to relevant documentation or resources
func (o ExperimentOutput) Links() ExperimentLinkArrayOutput {
	return o.ApplyT(func(v *Experiment) ExperimentLinkArrayOutput { return v.Links }).(ExperimentLinkArrayOutput)
}

// The name of the new experiment
func (o ExperimentOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Primary metric tags for the experiment
func (o ExperimentOutput) PrimaryMetricTags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringArrayOutput { return v.PrimaryMetricTags }).(pulumi.StringArrayOutput)
}

// Main metrics needed to evaluate your hypothesis
func (o ExperimentOutput) PrimaryMetrics() ExperimentPrimaryMetricArrayOutput {
	return o.ApplyT(func(v *Experiment) ExperimentPrimaryMetricArrayOutput { return v.PrimaryMetrics }).(ExperimentPrimaryMetricArrayOutput)
}

// Warehouse Native only - UTC hour at which to run scheduled pulse loads
func (o ExperimentOutput) ScheduledReloadHour() pulumi.IntOutput {
	return o.ApplyT(func(v *Experiment) pulumi.IntOutput { return v.ScheduledReloadHour }).(pulumi.IntOutput)
}

// Warehouse Native only - reload type for scheduled reloads
func (o ExperimentOutput) ScheduledReloadType() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.ScheduledReloadType }).(pulumi.StringOutput)
}

// The secondary ID type for the experiment used in WHN for ID resolution
func (o ExperimentOutput) SecondaryIdtype() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.SecondaryIdtype }).(pulumi.StringOutput)
}

// Secondary metric tags for the experiment
func (o ExperimentOutput) SecondaryMetricTags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringArrayOutput { return v.SecondaryMetricTags }).(pulumi.StringArrayOutput)
}

// Additional metrics to monitor that might impact the analysis or final decision of the experiment
func (o ExperimentOutput) SecondaryMetrics() ExperimentSecondaryMetricArrayOutput {
	return o.ApplyT(func(v *Experiment) ExperimentSecondaryMetricArrayOutput { return v.SecondaryMetrics }).(ExperimentSecondaryMetricArrayOutput)
}

// Apply sequential testing?
func (o ExperimentOutput) SequentialTesting() pulumi.BoolOutput {
	return o.ApplyT(func(v *Experiment) pulumi.BoolOutput { return v.SequentialTesting }).(pulumi.BoolOutput)
}

// The current status of the experiment
func (o ExperimentOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// Tags associated with the experiment
func (o ExperimentOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// Target apps assigned to this experiment
func (o ExperimentOutput) TargetApps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringArrayOutput { return v.TargetApps }).(pulumi.StringArrayOutput)
}

// Target exposures for the experiment
func (o ExperimentOutput) TargetExposures() pulumi.IntOutput {
	return o.ApplyT(func(v *Experiment) pulumi.IntOutput { return v.TargetExposures }).(pulumi.IntOutput)
}

// Restrict your experiment to users passing the selected feature gate
func (o ExperimentOutput) TargetingGateId() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.TargetingGateId }).(pulumi.StringOutput)
}

// Enterprise only
func (o ExperimentOutput) Team() pulumi.StringOutput {
	return o.ApplyT(func(v *Experiment) pulumi.StringOutput { return v.Team }).(pulumi.StringOutput)
}

type ExperimentArrayOutput struct{ *pulumi.OutputState }

func (ExperimentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Experiment)(nil)).Elem()
}

func (o ExperimentArrayOutput) ToExperimentArrayOutput() ExperimentArrayOutput {
	return o
}

func (o ExperimentArrayOutput) ToExperimentArrayOutputWithContext(ctx context.Context) ExperimentArrayOutput {
	return o
}

func (o ExperimentArrayOutput) Index(i pulumi.IntInput) ExperimentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Experiment {
		return vs[0].([]*Experiment)[vs[1].(int)]
	}).(ExperimentOutput)
}

type ExperimentMapOutput struct{ *pulumi.OutputState }

func (ExperimentMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Experiment)(nil)).Elem()
}

func (o ExperimentMapOutput) ToExperimentMapOutput() ExperimentMapOutput {
	return o
}

func (o ExperimentMapOutput) ToExperimentMapOutputWithContext(ctx context.Context) ExperimentMapOutput {
	return o
}

func (o ExperimentMapOutput) MapIndex(k pulumi.StringInput) ExperimentOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Experiment {
		return vs[0].(map[string]*Experiment)[vs[1].(string)]
	}).(ExperimentOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ExperimentInput)(nil)).Elem(), &Experiment{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExperimentArrayInput)(nil)).Elem(), ExperimentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExperimentMapInput)(nil)).Elem(), ExperimentMap{})
	pulumi.RegisterOutputType(ExperimentOutput{})
	pulumi.RegisterOutputType(ExperimentArrayOutput{})
	pulumi.RegisterOutputType(ExperimentMapOutput{})
}
