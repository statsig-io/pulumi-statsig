# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'EntityPropertyIdTypeMapping',
    'EntityPropertyOwner',
    'ExperimentGroup',
    'ExperimentLink',
    'ExperimentPrimaryMetric',
    'ExperimentSecondaryMetric',
    'GateMonitoringMetric',
    'GateRule',
    'GateRuleCondition',
    'GateRuleReturnValue',
    'MetricFunnelEventList',
    'MetricMetricComponentMetric',
    'MetricMetricEvent',
    'MetricMetricEventCriteria',
    'MetricSourceCustomFieldMapping',
    'MetricSourceIdTypeMapping',
    'MetricSourceOwner',
    'MetricWarehouseNative',
    'MetricWarehouseNativeCriteria',
    'MetricWarehouseNativeDenominatorCriteria',
    'MetricWarehouseNativeFunnelEvent',
    'MetricWarehouseNativeFunnelEventCriteria',
]

@pulumi.output_type
class EntityPropertyIdTypeMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statsigUnitId":
            suggest = "statsig_unit_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntityPropertyIdTypeMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntityPropertyIdTypeMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntityPropertyIdTypeMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: builtins.str,
                 statsig_unit_id: builtins.str):
        """
        :param builtins.str column: Column name linked to the ID.
        :param builtins.str statsig_unit_id: ID for the Statsig unit.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "statsig_unit_id", statsig_unit_id)

    @property
    @pulumi.getter
    def column(self) -> builtins.str:
        """
        Column name linked to the ID.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="statsigUnitId")
    def statsig_unit_id(self) -> builtins.str:
        """
        ID for the Statsig unit.
        """
        return pulumi.get(self, "statsig_unit_id")


@pulumi.output_type
class EntityPropertyOwner(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ownerEmail":
            suggest = "owner_email"
        elif key == "ownerId":
            suggest = "owner_id"
        elif key == "ownerName":
            suggest = "owner_name"
        elif key == "ownerType":
            suggest = "owner_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntityPropertyOwner. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntityPropertyOwner.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntityPropertyOwner.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 owner_email: Optional[builtins.str] = None,
                 owner_id: Optional[builtins.str] = None,
                 owner_name: Optional[builtins.str] = None,
                 owner_type: Optional[builtins.str] = None):
        """
        :param builtins.str owner_email: The email of the owner. This field is optional.
        :param builtins.str owner_id: ID of the owner
        :param builtins.str owner_name: The name of the owner. This field is optional.
        :param builtins.str owner_type: Type of the owner (e.g., SDK_KEY or USER)
        """
        if owner_email is not None:
            pulumi.set(__self__, "owner_email", owner_email)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if owner_name is not None:
            pulumi.set(__self__, "owner_name", owner_name)
        if owner_type is not None:
            pulumi.set(__self__, "owner_type", owner_type)

    @property
    @pulumi.getter(name="ownerEmail")
    def owner_email(self) -> Optional[builtins.str]:
        """
        The email of the owner. This field is optional.
        """
        return pulumi.get(self, "owner_email")

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[builtins.str]:
        """
        ID of the owner
        """
        return pulumi.get(self, "owner_id")

    @property
    @pulumi.getter(name="ownerName")
    def owner_name(self) -> Optional[builtins.str]:
        """
        The name of the owner. This field is optional.
        """
        return pulumi.get(self, "owner_name")

    @property
    @pulumi.getter(name="ownerType")
    def owner_type(self) -> Optional[builtins.str]:
        """
        Type of the owner (e.g., SDK_KEY or USER)
        """
        return pulumi.get(self, "owner_type")


@pulumi.output_type
class ExperimentGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterValues":
            suggest = "parameter_values"
        elif key == "foreignGroupId":
            suggest = "foreign_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExperimentGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExperimentGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExperimentGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 parameter_values: Mapping[str, builtins.str],
                 size: builtins.float,
                 description: Optional[builtins.str] = None,
                 disabled: Optional[builtins.bool] = None,
                 foreign_group_id: Optional[builtins.str] = None,
                 id: Optional[builtins.str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parameter_values", parameter_values)
        pulumi.set(__self__, "size", size)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if foreign_group_id is not None:
            pulumi.set(__self__, "foreign_group_id", foreign_group_id)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parameterValues")
    def parameter_values(self) -> Mapping[str, builtins.str]:
        return pulumi.get(self, "parameter_values")

    @property
    @pulumi.getter
    def size(self) -> builtins.float:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="foreignGroupId")
    def foreign_group_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "foreign_group_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ExperimentLink(dict):
    def __init__(__self__, *,
                 url: builtins.str,
                 title: Optional[builtins.str] = None):
        """
        :param builtins.str url: The URL of the link
        :param builtins.str title: The title of the link
        """
        pulumi.set(__self__, "url", url)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def url(self) -> builtins.str:
        """
        The URL of the link
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def title(self) -> Optional[builtins.str]:
        """
        The title of the link
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class ExperimentPrimaryMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hypothesizedValue":
            suggest = "hypothesized_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExperimentPrimaryMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExperimentPrimaryMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExperimentPrimaryMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direction: Optional[builtins.str] = None,
                 hypothesized_value: Optional[builtins.float] = None,
                 name: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if hypothesized_value is not None:
            pulumi.set(__self__, "hypothesized_value", hypothesized_value)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> Optional[builtins.str]:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="hypothesizedValue")
    def hypothesized_value(self) -> Optional[builtins.float]:
        return pulumi.get(self, "hypothesized_value")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ExperimentSecondaryMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hypothesizedValue":
            suggest = "hypothesized_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExperimentSecondaryMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExperimentSecondaryMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExperimentSecondaryMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direction: Optional[builtins.str] = None,
                 hypothesized_value: Optional[builtins.float] = None,
                 name: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if hypothesized_value is not None:
            pulumi.set(__self__, "hypothesized_value", hypothesized_value)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> Optional[builtins.str]:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="hypothesizedValue")
    def hypothesized_value(self) -> Optional[builtins.float]:
        return pulumi.get(self, "hypothesized_value")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GateMonitoringMetric(dict):
    def __init__(__self__, *,
                 name: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GateRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passPercentage":
            suggest = "pass_percentage"
        elif key == "baseId":
            suggest = "base_id"
        elif key == "returnValue":
            suggest = "return_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GateRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GateRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GateRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Sequence['outputs.GateRuleCondition'],
                 name: builtins.str,
                 pass_percentage: builtins.float,
                 base_id: Optional[builtins.str] = None,
                 environments: Optional[Sequence[builtins.str]] = None,
                 id: Optional[builtins.str] = None,
                 return_value: Optional['outputs.GateRuleReturnValue'] = None):
        """
        :param Sequence['GateRuleConditionArgs'] conditions: An array of Condition objects.
        :param builtins.str name: The name of this rule.
        :param builtins.float pass_percentage: Of the users that meet the conditions of this rule, what percent should return true.
        :param builtins.str base_id: The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
        :param Sequence[builtins.str] environments: The environments this rule is enabled for.
        :param builtins.str id: The Statsig ID of this rule.
        :param 'GateRuleReturnValueArgs' return_value: The return value of the rule.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pass_percentage", pass_percentage)
        if base_id is not None:
            pulumi.set(__self__, "base_id", base_id)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if return_value is not None:
            pulumi.set(__self__, "return_value", return_value)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.GateRuleCondition']:
        """
        An array of Condition objects.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of this rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="passPercentage")
    def pass_percentage(self) -> builtins.float:
        """
        Of the users that meet the conditions of this rule, what percent should return true.
        """
        return pulumi.get(self, "pass_percentage")

    @property
    @pulumi.getter(name="baseId")
    def base_id(self) -> Optional[builtins.str]:
        """
        The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
        """
        return pulumi.get(self, "base_id")

    @property
    @pulumi.getter
    def environments(self) -> Optional[Sequence[builtins.str]]:
        """
        The environments this rule is enabled for.
        """
        return pulumi.get(self, "environments")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        The Statsig ID of this rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="returnValue")
    def return_value(self) -> Optional['outputs.GateRuleReturnValue']:
        """
        The return value of the rule.
        """
        return pulumi.get(self, "return_value")


@pulumi.output_type
class GateRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customId":
            suggest = "custom_id"
        elif key == "targetValues":
            suggest = "target_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GateRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GateRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GateRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 custom_id: Optional[builtins.str] = None,
                 field: Optional[builtins.str] = None,
                 operator: Optional[builtins.str] = None,
                 target_values: Optional[Sequence[builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        if custom_id is not None:
            pulumi.set(__self__, "custom_id", custom_id)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if target_values is not None:
            pulumi.set(__self__, "target_values", target_values)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="customId")
    def custom_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "custom_id")

    @property
    @pulumi.getter
    def field(self) -> Optional[builtins.str]:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="targetValues")
    def target_values(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "target_values")


@pulumi.output_type
class GateRuleReturnValue(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class MetricFunnelEventList(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 type: builtins.str):
        """
        :param builtins.str name: The name of the funnel event used in the metric.
        :param builtins.str type: The type of funnel event, specifying how the event is tracked.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the funnel event used in the metric.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of funnel event, specifying how the event is tracked.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MetricMetricComponentMetric(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 type: builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class MetricMetricEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataKey":
            suggest = "metadata_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricMetricEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricMetricEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricMetricEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 criterias: Optional[Sequence['outputs.MetricMetricEventCriteria']] = None,
                 metadata_key: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the metric event.
        :param Sequence['MetricMetricEventCriteriaArgs'] criterias: Filtering criteria for the metric event, including conditions and values to refine the event data.
        :param builtins.str metadata_key: The key for associated metadata, if applicable.
        :param builtins.str type: The type of metric event. Allowed values include: count, count_distinct, value, and metadata.
        """
        pulumi.set(__self__, "name", name)
        if criterias is not None:
            pulumi.set(__self__, "criterias", criterias)
        if metadata_key is not None:
            pulumi.set(__self__, "metadata_key", metadata_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the metric event.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def criterias(self) -> Optional[Sequence['outputs.MetricMetricEventCriteria']]:
        """
        Filtering criteria for the metric event, including conditions and values to refine the event data.
        """
        return pulumi.get(self, "criterias")

    @property
    @pulumi.getter(name="metadataKey")
    def metadata_key(self) -> Optional[builtins.str]:
        """
        The key for associated metadata, if applicable.
        """
        return pulumi.get(self, "metadata_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        The type of metric event. Allowed values include: count, count_distinct, value, and metadata.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MetricMetricEventCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nullVacuousOverride":
            suggest = "null_vacuous_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricMetricEventCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricMetricEventCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricMetricEventCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: builtins.str,
                 type: builtins.str,
                 column: Optional[builtins.str] = None,
                 null_vacuous_override: Optional[builtins.bool] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str condition: sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        :param builtins.str type: Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        :param builtins.str column: Optional column specifying which data attribute to filter on.
        :param builtins.bool null_vacuous_override: If true, overrides null values in criterion evaluation.
        :param Sequence[builtins.str] values: Optional array of values for the criterion to match against.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "type", type)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if null_vacuous_override is not None:
            pulumi.set(__self__, "null_vacuous_override", null_vacuous_override)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def column(self) -> Optional[builtins.str]:
        """
        Optional column specifying which data attribute to filter on.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="nullVacuousOverride")
    def null_vacuous_override(self) -> Optional[builtins.bool]:
        """
        If true, overrides null values in criterion evaluation.
        """
        return pulumi.get(self, "null_vacuous_override")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional array of values for the criterion to match against.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class MetricSourceCustomFieldMapping(dict):
    def __init__(__self__, *,
                 formula: builtins.str,
                 key: builtins.str):
        """
        :param builtins.str formula: The formula or expression used to compute the custom field value.
        :param builtins.str key: The identifier for the custom field mapping.
        """
        pulumi.set(__self__, "formula", formula)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def formula(self) -> builtins.str:
        """
        The formula or expression used to compute the custom field value.
        """
        return pulumi.get(self, "formula")

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        """
        The identifier for the custom field mapping.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class MetricSourceIdTypeMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statsigUnitId":
            suggest = "statsig_unit_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricSourceIdTypeMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricSourceIdTypeMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricSourceIdTypeMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: builtins.str,
                 statsig_unit_id: builtins.str):
        """
        :param builtins.str column: The corresponding column name in the source that relates to the Statsig unit ID.
        :param builtins.str statsig_unit_id: The identifier mapping for Statsig units.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "statsig_unit_id", statsig_unit_id)

    @property
    @pulumi.getter
    def column(self) -> builtins.str:
        """
        The corresponding column name in the source that relates to the Statsig unit ID.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="statsigUnitId")
    def statsig_unit_id(self) -> builtins.str:
        """
        The identifier mapping for Statsig units.
        """
        return pulumi.get(self, "statsig_unit_id")


@pulumi.output_type
class MetricSourceOwner(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ownerEmail":
            suggest = "owner_email"
        elif key == "ownerId":
            suggest = "owner_id"
        elif key == "ownerName":
            suggest = "owner_name"
        elif key == "ownerType":
            suggest = "owner_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricSourceOwner. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricSourceOwner.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricSourceOwner.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 owner_email: Optional[builtins.str] = None,
                 owner_id: Optional[builtins.str] = None,
                 owner_name: Optional[builtins.str] = None,
                 owner_type: Optional[builtins.str] = None):
        """
        :param builtins.str owner_email: The email of the owner. This field is optional.
        :param builtins.str owner_id: ID of the owner
        :param builtins.str owner_name: The name of the owner. This field is optional.
        :param builtins.str owner_type: Type of the owner (e.g., SDK_KEY or USER)
        """
        if owner_email is not None:
            pulumi.set(__self__, "owner_email", owner_email)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if owner_name is not None:
            pulumi.set(__self__, "owner_name", owner_name)
        if owner_type is not None:
            pulumi.set(__self__, "owner_type", owner_type)

    @property
    @pulumi.getter(name="ownerEmail")
    def owner_email(self) -> Optional[builtins.str]:
        """
        The email of the owner. This field is optional.
        """
        return pulumi.get(self, "owner_email")

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[builtins.str]:
        """
        ID of the owner
        """
        return pulumi.get(self, "owner_id")

    @property
    @pulumi.getter(name="ownerName")
    def owner_name(self) -> Optional[builtins.str]:
        """
        The name of the owner. This field is optional.
        """
        return pulumi.get(self, "owner_name")

    @property
    @pulumi.getter(name="ownerType")
    def owner_type(self) -> Optional[builtins.str]:
        """
        Type of the owner (e.g., SDK_KEY or USER)
        """
        return pulumi.get(self, "owner_type")


@pulumi.output_type
class MetricWarehouseNative(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowNullRatioDenominator":
            suggest = "allow_null_ratio_denominator"
        elif key == "cupedAttributionWindow":
            suggest = "cuped_attribution_window"
        elif key == "customRollUpEnd":
            suggest = "custom_roll_up_end"
        elif key == "customRollUpStart":
            suggest = "custom_roll_up_start"
        elif key == "denominatorAggregation":
            suggest = "denominator_aggregation"
        elif key == "denominatorCriterias":
            suggest = "denominator_criterias"
        elif key == "denominatorCustomRollupEnd":
            suggest = "denominator_custom_rollup_end"
        elif key == "denominatorCustomRollupStart":
            suggest = "denominator_custom_rollup_start"
        elif key == "denominatorMetricSourceName":
            suggest = "denominator_metric_source_name"
        elif key == "denominatorRollupTimeWindow":
            suggest = "denominator_rollup_time_window"
        elif key == "denominatorValueColumn":
            suggest = "denominator_value_column"
        elif key == "funnelCalculationWindow":
            suggest = "funnel_calculation_window"
        elif key == "funnelCountDistinct":
            suggest = "funnel_count_distinct"
        elif key == "funnelEvents":
            suggest = "funnel_events"
        elif key == "funnelStartCriteria":
            suggest = "funnel_start_criteria"
        elif key == "metricBakeDays":
            suggest = "metric_bake_days"
        elif key == "metricDimensionColumns":
            suggest = "metric_dimension_columns"
        elif key == "metricSourceName":
            suggest = "metric_source_name"
        elif key == "numeratorAggregation":
            suggest = "numerator_aggregation"
        elif key == "onlyIncludeUsersWithConversionEvent":
            suggest = "only_include_users_with_conversion_event"
        elif key == "rollupTimeWindow":
            suggest = "rollup_time_window"
        elif key == "valueColumn":
            suggest = "value_column"
        elif key == "valueThreshold":
            suggest = "value_threshold"
        elif key == "waitForCohortWindow":
            suggest = "wait_for_cohort_window"
        elif key == "winsorizationHigh":
            suggest = "winsorization_high"
        elif key == "winsorizationLow":
            suggest = "winsorization_low"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricWarehouseNative. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricWarehouseNative.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricWarehouseNative.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation: Optional[builtins.str] = None,
                 allow_null_ratio_denominator: Optional[builtins.bool] = None,
                 cap: Optional[builtins.float] = None,
                 criterias: Optional[Sequence['outputs.MetricWarehouseNativeCriteria']] = None,
                 cuped_attribution_window: Optional[builtins.float] = None,
                 custom_roll_up_end: Optional[builtins.float] = None,
                 custom_roll_up_start: Optional[builtins.float] = None,
                 denominator_aggregation: Optional[builtins.str] = None,
                 denominator_criterias: Optional[Sequence['outputs.MetricWarehouseNativeDenominatorCriteria']] = None,
                 denominator_custom_rollup_end: Optional[builtins.float] = None,
                 denominator_custom_rollup_start: Optional[builtins.float] = None,
                 denominator_metric_source_name: Optional[builtins.str] = None,
                 denominator_rollup_time_window: Optional[builtins.str] = None,
                 denominator_value_column: Optional[builtins.str] = None,
                 funnel_calculation_window: Optional[builtins.float] = None,
                 funnel_count_distinct: Optional[builtins.str] = None,
                 funnel_events: Optional[Sequence['outputs.MetricWarehouseNativeFunnelEvent']] = None,
                 funnel_start_criteria: Optional[builtins.str] = None,
                 metric_bake_days: Optional[builtins.float] = None,
                 metric_dimension_columns: Optional[Sequence[builtins.str]] = None,
                 metric_source_name: Optional[builtins.str] = None,
                 numerator_aggregation: Optional[builtins.str] = None,
                 only_include_users_with_conversion_event: Optional[builtins.bool] = None,
                 percentile: Optional[builtins.float] = None,
                 rollup_time_window: Optional[builtins.str] = None,
                 value_column: Optional[builtins.str] = None,
                 value_threshold: Optional[builtins.float] = None,
                 wait_for_cohort_window: Optional[builtins.bool] = None,
                 winsorization_high: Optional[builtins.float] = None,
                 winsorization_low: Optional[builtins.float] = None):
        """
        :param builtins.str aggregation: Allowed: count┃sum┃mean┃daily*participation┃ratio┃funnel┃count*distinct┃percentile
        :param builtins.bool allow_null_ratio_denominator: Include units which do not have a denominator. Only applicable to ratios.
        :param builtins.float cap: Maximum cap for metric values.
        :param Sequence['MetricWarehouseNativeCriteriaArgs'] criterias: Filtering criteria for the metric source
        :param builtins.float cuped_attribution_window: Attribution window for CUPED adjustments in days.
        :param builtins.float custom_roll_up_end: Custom end date for rollup in days since exposure.
        :param builtins.float custom_roll_up_start: Custom start date for rollup in days since exposure.
        :param builtins.str denominator_aggregation: Allowed: count┃sum┃mean┃daily*participation┃ratio┃funnel┃count*distinct┃percentile
        :param Sequence['MetricWarehouseNativeDenominatorCriteriaArgs'] denominator_criterias: Filtering criteria for the denominator metric source, if this metric is a ratio
        :param builtins.float denominator_custom_rollup_end: Custom end date for rollup in days since exposure.
        :param builtins.float denominator_custom_rollup_start: Custom start date for rollup in days since exposure.
        :param builtins.str denominator_metric_source_name: Name of the metric source for the denominator.
        :param builtins.str denominator_rollup_time_window: Time window for the denominator metric. Specify "custom" for a custom window.
        :param builtins.str denominator_value_column: Column name for the denominator’s value.
        :param builtins.float funnel_calculation_window: Duration for counting funnel events in days.
        :param builtins.str funnel_count_distinct: Allowed: users┃sessions for distinct count method in funnel events.
        :param Sequence['MetricWarehouseNativeFunnelEventArgs'] funnel_events: List of funnel events with associated criteria and identifiers.
        :param builtins.str funnel_start_criteria: Allowed: start_event┃exposure to determine funnel start criteria.
        :param builtins.float metric_bake_days: Number of days for metric baking; specify duration for analysis.
        :param Sequence[builtins.str] metric_dimension_columns: Specify metadata columns for breaking down metric analysis.
        :param builtins.str metric_source_name: For Count, Sum, Mean, User Count aggregation types: the name of metric source
        :param builtins.str numerator_aggregation: Aggregation type for numerator; Allowed: count┃sum┃mean┃daily*participation┃ratio┃funnel┃count*distinct┃percentile.
        :param builtins.bool only_include_users_with_conversion_event: Flag to include only users with a conversion event in the metric.
        :param builtins.float percentile: Percentile value for statistical calculations.
        :param builtins.str rollup_time_window: General time window for rollup; can specify custom settings.
        :param builtins.str value_column: Column name representing the metric’s value.
        :param builtins.float value_threshold: Threshold value for filtering metrics.
        :param builtins.float winsorization_high: High threshold for winsorization; must be between 0 and 1.
        :param builtins.float winsorization_low: Low threshold for winsorization; must be between 0 and 1.
        """
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if allow_null_ratio_denominator is not None:
            pulumi.set(__self__, "allow_null_ratio_denominator", allow_null_ratio_denominator)
        if cap is not None:
            pulumi.set(__self__, "cap", cap)
        if criterias is not None:
            pulumi.set(__self__, "criterias", criterias)
        if cuped_attribution_window is not None:
            pulumi.set(__self__, "cuped_attribution_window", cuped_attribution_window)
        if custom_roll_up_end is not None:
            pulumi.set(__self__, "custom_roll_up_end", custom_roll_up_end)
        if custom_roll_up_start is not None:
            pulumi.set(__self__, "custom_roll_up_start", custom_roll_up_start)
        if denominator_aggregation is not None:
            pulumi.set(__self__, "denominator_aggregation", denominator_aggregation)
        if denominator_criterias is not None:
            pulumi.set(__self__, "denominator_criterias", denominator_criterias)
        if denominator_custom_rollup_end is not None:
            pulumi.set(__self__, "denominator_custom_rollup_end", denominator_custom_rollup_end)
        if denominator_custom_rollup_start is not None:
            pulumi.set(__self__, "denominator_custom_rollup_start", denominator_custom_rollup_start)
        if denominator_metric_source_name is not None:
            pulumi.set(__self__, "denominator_metric_source_name", denominator_metric_source_name)
        if denominator_rollup_time_window is not None:
            pulumi.set(__self__, "denominator_rollup_time_window", denominator_rollup_time_window)
        if denominator_value_column is not None:
            pulumi.set(__self__, "denominator_value_column", denominator_value_column)
        if funnel_calculation_window is not None:
            pulumi.set(__self__, "funnel_calculation_window", funnel_calculation_window)
        if funnel_count_distinct is not None:
            pulumi.set(__self__, "funnel_count_distinct", funnel_count_distinct)
        if funnel_events is not None:
            pulumi.set(__self__, "funnel_events", funnel_events)
        if funnel_start_criteria is not None:
            pulumi.set(__self__, "funnel_start_criteria", funnel_start_criteria)
        if metric_bake_days is not None:
            pulumi.set(__self__, "metric_bake_days", metric_bake_days)
        if metric_dimension_columns is not None:
            pulumi.set(__self__, "metric_dimension_columns", metric_dimension_columns)
        if metric_source_name is not None:
            pulumi.set(__self__, "metric_source_name", metric_source_name)
        if numerator_aggregation is not None:
            pulumi.set(__self__, "numerator_aggregation", numerator_aggregation)
        if only_include_users_with_conversion_event is not None:
            pulumi.set(__self__, "only_include_users_with_conversion_event", only_include_users_with_conversion_event)
        if percentile is not None:
            pulumi.set(__self__, "percentile", percentile)
        if rollup_time_window is not None:
            pulumi.set(__self__, "rollup_time_window", rollup_time_window)
        if value_column is not None:
            pulumi.set(__self__, "value_column", value_column)
        if value_threshold is not None:
            pulumi.set(__self__, "value_threshold", value_threshold)
        if wait_for_cohort_window is not None:
            pulumi.set(__self__, "wait_for_cohort_window", wait_for_cohort_window)
        if winsorization_high is not None:
            pulumi.set(__self__, "winsorization_high", winsorization_high)
        if winsorization_low is not None:
            pulumi.set(__self__, "winsorization_low", winsorization_low)

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[builtins.str]:
        """
        Allowed: count┃sum┃mean┃daily*participation┃ratio┃funnel┃count*distinct┃percentile
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="allowNullRatioDenominator")
    def allow_null_ratio_denominator(self) -> Optional[builtins.bool]:
        """
        Include units which do not have a denominator. Only applicable to ratios.
        """
        return pulumi.get(self, "allow_null_ratio_denominator")

    @property
    @pulumi.getter
    def cap(self) -> Optional[builtins.float]:
        """
        Maximum cap for metric values.
        """
        return pulumi.get(self, "cap")

    @property
    @pulumi.getter
    def criterias(self) -> Optional[Sequence['outputs.MetricWarehouseNativeCriteria']]:
        """
        Filtering criteria for the metric source
        """
        return pulumi.get(self, "criterias")

    @property
    @pulumi.getter(name="cupedAttributionWindow")
    def cuped_attribution_window(self) -> Optional[builtins.float]:
        """
        Attribution window for CUPED adjustments in days.
        """
        return pulumi.get(self, "cuped_attribution_window")

    @property
    @pulumi.getter(name="customRollUpEnd")
    def custom_roll_up_end(self) -> Optional[builtins.float]:
        """
        Custom end date for rollup in days since exposure.
        """
        return pulumi.get(self, "custom_roll_up_end")

    @property
    @pulumi.getter(name="customRollUpStart")
    def custom_roll_up_start(self) -> Optional[builtins.float]:
        """
        Custom start date for rollup in days since exposure.
        """
        return pulumi.get(self, "custom_roll_up_start")

    @property
    @pulumi.getter(name="denominatorAggregation")
    def denominator_aggregation(self) -> Optional[builtins.str]:
        """
        Allowed: count┃sum┃mean┃daily*participation┃ratio┃funnel┃count*distinct┃percentile
        """
        return pulumi.get(self, "denominator_aggregation")

    @property
    @pulumi.getter(name="denominatorCriterias")
    def denominator_criterias(self) -> Optional[Sequence['outputs.MetricWarehouseNativeDenominatorCriteria']]:
        """
        Filtering criteria for the denominator metric source, if this metric is a ratio
        """
        return pulumi.get(self, "denominator_criterias")

    @property
    @pulumi.getter(name="denominatorCustomRollupEnd")
    def denominator_custom_rollup_end(self) -> Optional[builtins.float]:
        """
        Custom end date for rollup in days since exposure.
        """
        return pulumi.get(self, "denominator_custom_rollup_end")

    @property
    @pulumi.getter(name="denominatorCustomRollupStart")
    def denominator_custom_rollup_start(self) -> Optional[builtins.float]:
        """
        Custom start date for rollup in days since exposure.
        """
        return pulumi.get(self, "denominator_custom_rollup_start")

    @property
    @pulumi.getter(name="denominatorMetricSourceName")
    def denominator_metric_source_name(self) -> Optional[builtins.str]:
        """
        Name of the metric source for the denominator.
        """
        return pulumi.get(self, "denominator_metric_source_name")

    @property
    @pulumi.getter(name="denominatorRollupTimeWindow")
    def denominator_rollup_time_window(self) -> Optional[builtins.str]:
        """
        Time window for the denominator metric. Specify "custom" for a custom window.
        """
        return pulumi.get(self, "denominator_rollup_time_window")

    @property
    @pulumi.getter(name="denominatorValueColumn")
    def denominator_value_column(self) -> Optional[builtins.str]:
        """
        Column name for the denominator’s value.
        """
        return pulumi.get(self, "denominator_value_column")

    @property
    @pulumi.getter(name="funnelCalculationWindow")
    def funnel_calculation_window(self) -> Optional[builtins.float]:
        """
        Duration for counting funnel events in days.
        """
        return pulumi.get(self, "funnel_calculation_window")

    @property
    @pulumi.getter(name="funnelCountDistinct")
    def funnel_count_distinct(self) -> Optional[builtins.str]:
        """
        Allowed: users┃sessions for distinct count method in funnel events.
        """
        return pulumi.get(self, "funnel_count_distinct")

    @property
    @pulumi.getter(name="funnelEvents")
    def funnel_events(self) -> Optional[Sequence['outputs.MetricWarehouseNativeFunnelEvent']]:
        """
        List of funnel events with associated criteria and identifiers.
        """
        return pulumi.get(self, "funnel_events")

    @property
    @pulumi.getter(name="funnelStartCriteria")
    def funnel_start_criteria(self) -> Optional[builtins.str]:
        """
        Allowed: start_event┃exposure to determine funnel start criteria.
        """
        return pulumi.get(self, "funnel_start_criteria")

    @property
    @pulumi.getter(name="metricBakeDays")
    def metric_bake_days(self) -> Optional[builtins.float]:
        """
        Number of days for metric baking; specify duration for analysis.
        """
        return pulumi.get(self, "metric_bake_days")

    @property
    @pulumi.getter(name="metricDimensionColumns")
    def metric_dimension_columns(self) -> Optional[Sequence[builtins.str]]:
        """
        Specify metadata columns for breaking down metric analysis.
        """
        return pulumi.get(self, "metric_dimension_columns")

    @property
    @pulumi.getter(name="metricSourceName")
    def metric_source_name(self) -> Optional[builtins.str]:
        """
        For Count, Sum, Mean, User Count aggregation types: the name of metric source
        """
        return pulumi.get(self, "metric_source_name")

    @property
    @pulumi.getter(name="numeratorAggregation")
    def numerator_aggregation(self) -> Optional[builtins.str]:
        """
        Aggregation type for numerator; Allowed: count┃sum┃mean┃daily*participation┃ratio┃funnel┃count*distinct┃percentile.
        """
        return pulumi.get(self, "numerator_aggregation")

    @property
    @pulumi.getter(name="onlyIncludeUsersWithConversionEvent")
    def only_include_users_with_conversion_event(self) -> Optional[builtins.bool]:
        """
        Flag to include only users with a conversion event in the metric.
        """
        return pulumi.get(self, "only_include_users_with_conversion_event")

    @property
    @pulumi.getter
    def percentile(self) -> Optional[builtins.float]:
        """
        Percentile value for statistical calculations.
        """
        return pulumi.get(self, "percentile")

    @property
    @pulumi.getter(name="rollupTimeWindow")
    def rollup_time_window(self) -> Optional[builtins.str]:
        """
        General time window for rollup; can specify custom settings.
        """
        return pulumi.get(self, "rollup_time_window")

    @property
    @pulumi.getter(name="valueColumn")
    def value_column(self) -> Optional[builtins.str]:
        """
        Column name representing the metric’s value.
        """
        return pulumi.get(self, "value_column")

    @property
    @pulumi.getter(name="valueThreshold")
    def value_threshold(self) -> Optional[builtins.float]:
        """
        Threshold value for filtering metrics.
        """
        return pulumi.get(self, "value_threshold")

    @property
    @pulumi.getter(name="waitForCohortWindow")
    def wait_for_cohort_window(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "wait_for_cohort_window")

    @property
    @pulumi.getter(name="winsorizationHigh")
    def winsorization_high(self) -> Optional[builtins.float]:
        """
        High threshold for winsorization; must be between 0 and 1.
        """
        return pulumi.get(self, "winsorization_high")

    @property
    @pulumi.getter(name="winsorizationLow")
    def winsorization_low(self) -> Optional[builtins.float]:
        """
        Low threshold for winsorization; must be between 0 and 1.
        """
        return pulumi.get(self, "winsorization_low")


@pulumi.output_type
class MetricWarehouseNativeCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nullVacuousOverride":
            suggest = "null_vacuous_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricWarehouseNativeCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricWarehouseNativeCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricWarehouseNativeCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: builtins.str,
                 type: builtins.str,
                 column: Optional[builtins.str] = None,
                 null_vacuous_override: Optional[builtins.bool] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str condition: sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        :param builtins.str type: Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        :param builtins.str column: Optional column specifying which data attribute to filter on.
        :param builtins.bool null_vacuous_override: If true, overrides null values in criterion evaluation.
        :param Sequence[builtins.str] values: Optional array of values for the criterion to match against.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "type", type)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if null_vacuous_override is not None:
            pulumi.set(__self__, "null_vacuous_override", null_vacuous_override)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def column(self) -> Optional[builtins.str]:
        """
        Optional column specifying which data attribute to filter on.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="nullVacuousOverride")
    def null_vacuous_override(self) -> Optional[builtins.bool]:
        """
        If true, overrides null values in criterion evaluation.
        """
        return pulumi.get(self, "null_vacuous_override")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional array of values for the criterion to match against.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class MetricWarehouseNativeDenominatorCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nullVacuousOverride":
            suggest = "null_vacuous_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricWarehouseNativeDenominatorCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricWarehouseNativeDenominatorCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricWarehouseNativeDenominatorCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: builtins.str,
                 type: builtins.str,
                 column: Optional[builtins.str] = None,
                 null_vacuous_override: Optional[builtins.bool] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str condition: sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        :param builtins.str type: Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        :param builtins.str column: Optional column specifying which data attribute to filter on.
        :param builtins.bool null_vacuous_override: If true, overrides null values in criterion evaluation.
        :param Sequence[builtins.str] values: Optional array of values for the criterion to match against.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "type", type)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if null_vacuous_override is not None:
            pulumi.set(__self__, "null_vacuous_override", null_vacuous_override)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def column(self) -> Optional[builtins.str]:
        """
        Optional column specifying which data attribute to filter on.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="nullVacuousOverride")
    def null_vacuous_override(self) -> Optional[builtins.bool]:
        """
        If true, overrides null values in criterion evaluation.
        """
        return pulumi.get(self, "null_vacuous_override")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional array of values for the criterion to match against.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class MetricWarehouseNativeFunnelEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricSourceName":
            suggest = "metric_source_name"
        elif key == "sessionIdentifierField":
            suggest = "session_identifier_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricWarehouseNativeFunnelEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricWarehouseNativeFunnelEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricWarehouseNativeFunnelEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 criterias: Optional[Sequence['outputs.MetricWarehouseNativeFunnelEventCriteria']] = None,
                 metric_source_name: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 session_identifier_field: Optional[builtins.str] = None):
        """
        :param Sequence['MetricWarehouseNativeFunnelEventCriteriaArgs'] criterias: Optional array of criteria to filter the funnel events, defined by various types and conditions.
        :param builtins.str metric_source_name: Optional name of the metric source associated with the funnel event.
        :param builtins.str name: Optional step name for the funnel event, can be null if not specified.
        :param builtins.str session_identifier_field: Name of column which being used as session identifier. Funnel event with the same metric source
        """
        if criterias is not None:
            pulumi.set(__self__, "criterias", criterias)
        if metric_source_name is not None:
            pulumi.set(__self__, "metric_source_name", metric_source_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if session_identifier_field is not None:
            pulumi.set(__self__, "session_identifier_field", session_identifier_field)

    @property
    @pulumi.getter
    def criterias(self) -> Optional[Sequence['outputs.MetricWarehouseNativeFunnelEventCriteria']]:
        """
        Optional array of criteria to filter the funnel events, defined by various types and conditions.
        """
        return pulumi.get(self, "criterias")

    @property
    @pulumi.getter(name="metricSourceName")
    def metric_source_name(self) -> Optional[builtins.str]:
        """
        Optional name of the metric source associated with the funnel event.
        """
        return pulumi.get(self, "metric_source_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Optional step name for the funnel event, can be null if not specified.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sessionIdentifierField")
    def session_identifier_field(self) -> Optional[builtins.str]:
        """
        Name of column which being used as session identifier. Funnel event with the same metric source
        """
        return pulumi.get(self, "session_identifier_field")


@pulumi.output_type
class MetricWarehouseNativeFunnelEventCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nullVacuousOverride":
            suggest = "null_vacuous_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricWarehouseNativeFunnelEventCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricWarehouseNativeFunnelEventCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricWarehouseNativeFunnelEventCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: builtins.str,
                 type: builtins.str,
                 column: Optional[builtins.str] = None,
                 null_vacuous_override: Optional[builtins.bool] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str condition: sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        :param builtins.str type: Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        :param builtins.str column: Optional column specifying which data attribute to filter on.
        :param builtins.bool null_vacuous_override: If true, overrides null values in criterion evaluation.
        :param Sequence[builtins.str] values: Optional array of values for the criterion to match against.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "type", type)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if null_vacuous_override is not None:
            pulumi.set(__self__, "null_vacuous_override", null_vacuous_override)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def column(self) -> Optional[builtins.str]:
        """
        Optional column specifying which data attribute to filter on.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="nullVacuousOverride")
    def null_vacuous_override(self) -> Optional[builtins.bool]:
        """
        If true, overrides null values in criterion evaluation.
        """
        return pulumi.get(self, "null_vacuous_override")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional array of values for the criterion to match against.
        """
        return pulumi.get(self, "values")


