# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['ExperimentArgs', 'Experiment']

@pulumi.input_type
class ExperimentArgs:
    def __init__(__self__, *,
                 allocation: Optional[pulumi.Input[builtins.float]] = None,
                 allocation_duration: Optional[pulumi.Input[builtins.int]] = None,
                 analysis_end_time: Optional[pulumi.Input[builtins.str]] = None,
                 analytics_type: Optional[pulumi.Input[builtins.str]] = None,
                 assignment_source_experiment_name: Optional[pulumi.Input[builtins.str]] = None,
                 assignment_source_name: Optional[pulumi.Input[builtins.str]] = None,
                 benjamini_hochberg_per_metric: Optional[pulumi.Input[builtins.bool]] = None,
                 benjamini_hochberg_per_variant: Optional[pulumi.Input[builtins.bool]] = None,
                 benjamini_primary_metrics_only: Optional[pulumi.Input[builtins.bool]] = None,
                 bonferroni_correction: Optional[pulumi.Input[builtins.bool]] = None,
                 bonferroni_correction_per_metric: Optional[pulumi.Input[builtins.bool]] = None,
                 cohort_wait_until_end_to_include: Optional[pulumi.Input[builtins.bool]] = None,
                 cohorted_analysis_duration: Optional[pulumi.Input[builtins.int]] = None,
                 cohorted_metrics_mature_after_end: Optional[pulumi.Input[builtins.bool]] = None,
                 control_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 creator_email: Optional[pulumi.Input[builtins.str]] = None,
                 creator_id: Optional[pulumi.Input[builtins.str]] = None,
                 default_confidence_interval: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 duration: Optional[pulumi.Input[builtins.int]] = None,
                 fixed_analysis_duration: Optional[pulumi.Input[builtins.int]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentGroupArgs']]]] = None,
                 hypothesis: Optional[pulumi.Input[builtins.str]] = None,
                 id_type: Optional[pulumi.Input[builtins.str]] = None,
                 is_analysis_only: Optional[pulumi.Input[builtins.bool]] = None,
                 launched_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 layer_id: Optional[pulumi.Input[builtins.str]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentLinkArgs']]]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 primary_metric_tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 primary_metrics: Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentPrimaryMetricArgs']]]] = None,
                 scheduled_reload_hour: Optional[pulumi.Input[builtins.int]] = None,
                 scheduled_reload_type: Optional[pulumi.Input[builtins.str]] = None,
                 secondary_idtype: Optional[pulumi.Input[builtins.str]] = None,
                 secondary_metric_tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 secondary_metrics: Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentSecondaryMetricArgs']]]] = None,
                 sequential_testing: Optional[pulumi.Input[builtins.bool]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 target_apps: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 target_exposures: Optional[pulumi.Input[builtins.int]] = None,
                 targeting_gate_id: Optional[pulumi.Input[builtins.str]] = None,
                 team: Optional[pulumi.Input[builtins.str]] = None):
        """
        The set of arguments for constructing a Experiment resource.
        :param pulumi.Input[builtins.float] allocation: Percent of layer allocated to this experiment
        :param pulumi.Input[builtins.int] allocation_duration: Warehouse Native Only - Allocation duration in days
        :param pulumi.Input[builtins.str] analysis_end_time: Warehouse Native only - end time for analysis only experiments
        :param pulumi.Input[builtins.str] analytics_type: The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
        :param pulumi.Input[builtins.str] assignment_source_experiment_name: Name of the source experiment for assignment
        :param pulumi.Input[builtins.str] assignment_source_name: Source name of the assignment
        :param pulumi.Input[builtins.bool] benjamini_hochberg_per_metric: Is Benjamini-Hochberg procedure applied per metric?
        :param pulumi.Input[builtins.bool] benjamini_hochberg_per_variant: Is Benjamini-Hochberg procedure applied per variant?
        :param pulumi.Input[builtins.bool] benjamini_primary_metrics_only: Is Benjamini-Hochberg procedure applied for primary metrics only?
        :param pulumi.Input[builtins.bool] bonferroni_correction: Is Bonferroni correction applied per variant?
        :param pulumi.Input[builtins.bool] bonferroni_correction_per_metric: Is Bonferroni correction applied per metric?
        :param pulumi.Input[builtins.bool] cohort_wait_until_end_to_include: Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
        :param pulumi.Input[builtins.int] cohorted_analysis_duration: Warehouse Native Only - Cohorted analysis duration in days
        :param pulumi.Input[builtins.bool] cohorted_metrics_mature_after_end: Warehouse Native Only - Allow cohort metrics to mature after experiment end
        :param pulumi.Input[builtins.str] control_group_id: Optional control group ID
        :param pulumi.Input[builtins.str] creator_email: The email of the creator of this experiment
        :param pulumi.Input[builtins.str] creator_id: The Statsig ID of the creator of this experiment
        :param pulumi.Input[builtins.str] default_confidence_interval: Default error margin used for results
        :param pulumi.Input[builtins.str] description: A description of the new experiment
        :param pulumi.Input[builtins.int] duration: How long the experiment is expected to last in days
        :param pulumi.Input[builtins.int] fixed_analysis_duration: Fixed analysis duration in days
        :param pulumi.Input[Sequence[pulumi.Input['ExperimentGroupArgs']]] groups: The test groups for your experiment
        :param pulumi.Input[builtins.str] hypothesis: A statement that will be tested by this experiment
        :param pulumi.Input[builtins.str] id_type: The idType the experiment will be performed on
        :param pulumi.Input[builtins.bool] is_analysis_only: For Warehouse Native
        :param pulumi.Input[builtins.str] launched_group_id: ID of the launched group, null otherwise
        :param pulumi.Input[builtins.str] layer_id: Which layer to place the experiment into.
        :param pulumi.Input[Sequence[pulumi.Input['ExperimentLinkArgs']]] links: Links to relevant documentation or resources
        :param pulumi.Input[builtins.str] name: The name of the new experiment
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] primary_metric_tags: Primary metric tags for the experiment
        :param pulumi.Input[Sequence[pulumi.Input['ExperimentPrimaryMetricArgs']]] primary_metrics: Main metrics needed to evaluate your hypothesis
        :param pulumi.Input[builtins.int] scheduled_reload_hour: Warehouse Native only - UTC hour at which to run scheduled pulse loads
        :param pulumi.Input[builtins.str] scheduled_reload_type: Warehouse Native only - reload type for scheduled reloads
        :param pulumi.Input[builtins.str] secondary_idtype: The secondary ID type for the experiment used in WHN for ID resolution
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] secondary_metric_tags: Secondary metric tags for the experiment
        :param pulumi.Input[Sequence[pulumi.Input['ExperimentSecondaryMetricArgs']]] secondary_metrics: Additional metrics to monitor that might impact the analysis or final decision of the experiment
        :param pulumi.Input[builtins.bool] sequential_testing: Apply sequential testing?
        :param pulumi.Input[builtins.str] status: The current status of the experiment
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tags: Tags associated with the experiment
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] target_apps: Target apps assigned to this experiment
        :param pulumi.Input[builtins.int] target_exposures: Target exposures for the experiment
        :param pulumi.Input[builtins.str] targeting_gate_id: Restrict your experiment to users passing the selected feature gate
        :param pulumi.Input[builtins.str] team: Enterprise only
        """
        if allocation is not None:
            pulumi.set(__self__, "allocation", allocation)
        if allocation_duration is not None:
            pulumi.set(__self__, "allocation_duration", allocation_duration)
        if analysis_end_time is not None:
            pulumi.set(__self__, "analysis_end_time", analysis_end_time)
        if analytics_type is not None:
            pulumi.set(__self__, "analytics_type", analytics_type)
        if assignment_source_experiment_name is not None:
            pulumi.set(__self__, "assignment_source_experiment_name", assignment_source_experiment_name)
        if assignment_source_name is not None:
            pulumi.set(__self__, "assignment_source_name", assignment_source_name)
        if benjamini_hochberg_per_metric is not None:
            pulumi.set(__self__, "benjamini_hochberg_per_metric", benjamini_hochberg_per_metric)
        if benjamini_hochberg_per_variant is not None:
            pulumi.set(__self__, "benjamini_hochberg_per_variant", benjamini_hochberg_per_variant)
        if benjamini_primary_metrics_only is not None:
            pulumi.set(__self__, "benjamini_primary_metrics_only", benjamini_primary_metrics_only)
        if bonferroni_correction is not None:
            pulumi.set(__self__, "bonferroni_correction", bonferroni_correction)
        if bonferroni_correction_per_metric is not None:
            pulumi.set(__self__, "bonferroni_correction_per_metric", bonferroni_correction_per_metric)
        if cohort_wait_until_end_to_include is not None:
            pulumi.set(__self__, "cohort_wait_until_end_to_include", cohort_wait_until_end_to_include)
        if cohorted_analysis_duration is not None:
            pulumi.set(__self__, "cohorted_analysis_duration", cohorted_analysis_duration)
        if cohorted_metrics_mature_after_end is not None:
            pulumi.set(__self__, "cohorted_metrics_mature_after_end", cohorted_metrics_mature_after_end)
        if control_group_id is not None:
            pulumi.set(__self__, "control_group_id", control_group_id)
        if creator_email is not None:
            pulumi.set(__self__, "creator_email", creator_email)
        if creator_id is not None:
            pulumi.set(__self__, "creator_id", creator_id)
        if default_confidence_interval is not None:
            pulumi.set(__self__, "default_confidence_interval", default_confidence_interval)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if fixed_analysis_duration is not None:
            pulumi.set(__self__, "fixed_analysis_duration", fixed_analysis_duration)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if hypothesis is not None:
            pulumi.set(__self__, "hypothesis", hypothesis)
        if id_type is not None:
            pulumi.set(__self__, "id_type", id_type)
        if is_analysis_only is not None:
            pulumi.set(__self__, "is_analysis_only", is_analysis_only)
        if launched_group_id is not None:
            pulumi.set(__self__, "launched_group_id", launched_group_id)
        if layer_id is not None:
            pulumi.set(__self__, "layer_id", layer_id)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_metric_tags is not None:
            pulumi.set(__self__, "primary_metric_tags", primary_metric_tags)
        if primary_metrics is not None:
            pulumi.set(__self__, "primary_metrics", primary_metrics)
        if scheduled_reload_hour is not None:
            pulumi.set(__self__, "scheduled_reload_hour", scheduled_reload_hour)
        if scheduled_reload_type is not None:
            pulumi.set(__self__, "scheduled_reload_type", scheduled_reload_type)
        if secondary_idtype is not None:
            pulumi.set(__self__, "secondary_idtype", secondary_idtype)
        if secondary_metric_tags is not None:
            pulumi.set(__self__, "secondary_metric_tags", secondary_metric_tags)
        if secondary_metrics is not None:
            pulumi.set(__self__, "secondary_metrics", secondary_metrics)
        if sequential_testing is not None:
            pulumi.set(__self__, "sequential_testing", sequential_testing)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if target_apps is not None:
            pulumi.set(__self__, "target_apps", target_apps)
        if target_exposures is not None:
            pulumi.set(__self__, "target_exposures", target_exposures)
        if targeting_gate_id is not None:
            pulumi.set(__self__, "targeting_gate_id", targeting_gate_id)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter
    def allocation(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Percent of layer allocated to this experiment
        """
        return pulumi.get(self, "allocation")

    @allocation.setter
    def allocation(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "allocation", value)

    @property
    @pulumi.getter(name="allocationDuration")
    def allocation_duration(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Warehouse Native Only - Allocation duration in days
        """
        return pulumi.get(self, "allocation_duration")

    @allocation_duration.setter
    def allocation_duration(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "allocation_duration", value)

    @property
    @pulumi.getter(name="analysisEndTime")
    def analysis_end_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Warehouse Native only - end time for analysis only experiments
        """
        return pulumi.get(self, "analysis_end_time")

    @analysis_end_time.setter
    def analysis_end_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "analysis_end_time", value)

    @property
    @pulumi.getter(name="analyticsType")
    def analytics_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
        """
        return pulumi.get(self, "analytics_type")

    @analytics_type.setter
    def analytics_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "analytics_type", value)

    @property
    @pulumi.getter(name="assignmentSourceExperimentName")
    def assignment_source_experiment_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the source experiment for assignment
        """
        return pulumi.get(self, "assignment_source_experiment_name")

    @assignment_source_experiment_name.setter
    def assignment_source_experiment_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "assignment_source_experiment_name", value)

    @property
    @pulumi.getter(name="assignmentSourceName")
    def assignment_source_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Source name of the assignment
        """
        return pulumi.get(self, "assignment_source_name")

    @assignment_source_name.setter
    def assignment_source_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "assignment_source_name", value)

    @property
    @pulumi.getter(name="benjaminiHochbergPerMetric")
    def benjamini_hochberg_per_metric(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Is Benjamini-Hochberg procedure applied per metric?
        """
        return pulumi.get(self, "benjamini_hochberg_per_metric")

    @benjamini_hochberg_per_metric.setter
    def benjamini_hochberg_per_metric(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "benjamini_hochberg_per_metric", value)

    @property
    @pulumi.getter(name="benjaminiHochbergPerVariant")
    def benjamini_hochberg_per_variant(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Is Benjamini-Hochberg procedure applied per variant?
        """
        return pulumi.get(self, "benjamini_hochberg_per_variant")

    @benjamini_hochberg_per_variant.setter
    def benjamini_hochberg_per_variant(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "benjamini_hochberg_per_variant", value)

    @property
    @pulumi.getter(name="benjaminiPrimaryMetricsOnly")
    def benjamini_primary_metrics_only(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Is Benjamini-Hochberg procedure applied for primary metrics only?
        """
        return pulumi.get(self, "benjamini_primary_metrics_only")

    @benjamini_primary_metrics_only.setter
    def benjamini_primary_metrics_only(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "benjamini_primary_metrics_only", value)

    @property
    @pulumi.getter(name="bonferroniCorrection")
    def bonferroni_correction(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Is Bonferroni correction applied per variant?
        """
        return pulumi.get(self, "bonferroni_correction")

    @bonferroni_correction.setter
    def bonferroni_correction(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "bonferroni_correction", value)

    @property
    @pulumi.getter(name="bonferroniCorrectionPerMetric")
    def bonferroni_correction_per_metric(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Is Bonferroni correction applied per metric?
        """
        return pulumi.get(self, "bonferroni_correction_per_metric")

    @bonferroni_correction_per_metric.setter
    def bonferroni_correction_per_metric(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "bonferroni_correction_per_metric", value)

    @property
    @pulumi.getter(name="cohortWaitUntilEndToInclude")
    def cohort_wait_until_end_to_include(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
        """
        return pulumi.get(self, "cohort_wait_until_end_to_include")

    @cohort_wait_until_end_to_include.setter
    def cohort_wait_until_end_to_include(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "cohort_wait_until_end_to_include", value)

    @property
    @pulumi.getter(name="cohortedAnalysisDuration")
    def cohorted_analysis_duration(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Warehouse Native Only - Cohorted analysis duration in days
        """
        return pulumi.get(self, "cohorted_analysis_duration")

    @cohorted_analysis_duration.setter
    def cohorted_analysis_duration(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cohorted_analysis_duration", value)

    @property
    @pulumi.getter(name="cohortedMetricsMatureAfterEnd")
    def cohorted_metrics_mature_after_end(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Warehouse Native Only - Allow cohort metrics to mature after experiment end
        """
        return pulumi.get(self, "cohorted_metrics_mature_after_end")

    @cohorted_metrics_mature_after_end.setter
    def cohorted_metrics_mature_after_end(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "cohorted_metrics_mature_after_end", value)

    @property
    @pulumi.getter(name="controlGroupId")
    def control_group_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional control group ID
        """
        return pulumi.get(self, "control_group_id")

    @control_group_id.setter
    def control_group_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "control_group_id", value)

    @property
    @pulumi.getter(name="creatorEmail")
    def creator_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The email of the creator of this experiment
        """
        return pulumi.get(self, "creator_email")

    @creator_email.setter
    def creator_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "creator_email", value)

    @property
    @pulumi.getter(name="creatorId")
    def creator_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Statsig ID of the creator of this experiment
        """
        return pulumi.get(self, "creator_id")

    @creator_id.setter
    def creator_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "creator_id", value)

    @property
    @pulumi.getter(name="defaultConfidenceInterval")
    def default_confidence_interval(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default error margin used for results
        """
        return pulumi.get(self, "default_confidence_interval")

    @default_confidence_interval.setter
    def default_confidence_interval(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_confidence_interval", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of the new experiment
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        How long the experiment is expected to last in days
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="fixedAnalysisDuration")
    def fixed_analysis_duration(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Fixed analysis duration in days
        """
        return pulumi.get(self, "fixed_analysis_duration")

    @fixed_analysis_duration.setter
    def fixed_analysis_duration(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "fixed_analysis_duration", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentGroupArgs']]]]:
        """
        The test groups for your experiment
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentGroupArgs']]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def hypothesis(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A statement that will be tested by this experiment
        """
        return pulumi.get(self, "hypothesis")

    @hypothesis.setter
    def hypothesis(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "hypothesis", value)

    @property
    @pulumi.getter(name="idType")
    def id_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The idType the experiment will be performed on
        """
        return pulumi.get(self, "id_type")

    @id_type.setter
    def id_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id_type", value)

    @property
    @pulumi.getter(name="isAnalysisOnly")
    def is_analysis_only(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        For Warehouse Native
        """
        return pulumi.get(self, "is_analysis_only")

    @is_analysis_only.setter
    def is_analysis_only(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_analysis_only", value)

    @property
    @pulumi.getter(name="launchedGroupId")
    def launched_group_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID of the launched group, null otherwise
        """
        return pulumi.get(self, "launched_group_id")

    @launched_group_id.setter
    def launched_group_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "launched_group_id", value)

    @property
    @pulumi.getter(name="layerId")
    def layer_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Which layer to place the experiment into.
        """
        return pulumi.get(self, "layer_id")

    @layer_id.setter
    def layer_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "layer_id", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentLinkArgs']]]]:
        """
        Links to relevant documentation or resources
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the new experiment
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="primaryMetricTags")
    def primary_metric_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Primary metric tags for the experiment
        """
        return pulumi.get(self, "primary_metric_tags")

    @primary_metric_tags.setter
    def primary_metric_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "primary_metric_tags", value)

    @property
    @pulumi.getter(name="primaryMetrics")
    def primary_metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentPrimaryMetricArgs']]]]:
        """
        Main metrics needed to evaluate your hypothesis
        """
        return pulumi.get(self, "primary_metrics")

    @primary_metrics.setter
    def primary_metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentPrimaryMetricArgs']]]]):
        pulumi.set(self, "primary_metrics", value)

    @property
    @pulumi.getter(name="scheduledReloadHour")
    def scheduled_reload_hour(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Warehouse Native only - UTC hour at which to run scheduled pulse loads
        """
        return pulumi.get(self, "scheduled_reload_hour")

    @scheduled_reload_hour.setter
    def scheduled_reload_hour(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "scheduled_reload_hour", value)

    @property
    @pulumi.getter(name="scheduledReloadType")
    def scheduled_reload_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Warehouse Native only - reload type for scheduled reloads
        """
        return pulumi.get(self, "scheduled_reload_type")

    @scheduled_reload_type.setter
    def scheduled_reload_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "scheduled_reload_type", value)

    @property
    @pulumi.getter(name="secondaryIdtype")
    def secondary_idtype(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The secondary ID type for the experiment used in WHN for ID resolution
        """
        return pulumi.get(self, "secondary_idtype")

    @secondary_idtype.setter
    def secondary_idtype(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secondary_idtype", value)

    @property
    @pulumi.getter(name="secondaryMetricTags")
    def secondary_metric_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Secondary metric tags for the experiment
        """
        return pulumi.get(self, "secondary_metric_tags")

    @secondary_metric_tags.setter
    def secondary_metric_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "secondary_metric_tags", value)

    @property
    @pulumi.getter(name="secondaryMetrics")
    def secondary_metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentSecondaryMetricArgs']]]]:
        """
        Additional metrics to monitor that might impact the analysis or final decision of the experiment
        """
        return pulumi.get(self, "secondary_metrics")

    @secondary_metrics.setter
    def secondary_metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentSecondaryMetricArgs']]]]):
        pulumi.set(self, "secondary_metrics", value)

    @property
    @pulumi.getter(name="sequentialTesting")
    def sequential_testing(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Apply sequential testing?
        """
        return pulumi.get(self, "sequential_testing")

    @sequential_testing.setter
    def sequential_testing(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "sequential_testing", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The current status of the experiment
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Tags associated with the experiment
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="targetApps")
    def target_apps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Target apps assigned to this experiment
        """
        return pulumi.get(self, "target_apps")

    @target_apps.setter
    def target_apps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "target_apps", value)

    @property
    @pulumi.getter(name="targetExposures")
    def target_exposures(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Target exposures for the experiment
        """
        return pulumi.get(self, "target_exposures")

    @target_exposures.setter
    def target_exposures(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "target_exposures", value)

    @property
    @pulumi.getter(name="targetingGateId")
    def targeting_gate_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Restrict your experiment to users passing the selected feature gate
        """
        return pulumi.get(self, "targeting_gate_id")

    @targeting_gate_id.setter
    def targeting_gate_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "targeting_gate_id", value)

    @property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Enterprise only
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "team", value)


@pulumi.input_type
class _ExperimentState:
    def __init__(__self__, *,
                 allocation: Optional[pulumi.Input[builtins.float]] = None,
                 allocation_duration: Optional[pulumi.Input[builtins.int]] = None,
                 analysis_end_time: Optional[pulumi.Input[builtins.str]] = None,
                 analytics_type: Optional[pulumi.Input[builtins.str]] = None,
                 assignment_source_experiment_name: Optional[pulumi.Input[builtins.str]] = None,
                 assignment_source_name: Optional[pulumi.Input[builtins.str]] = None,
                 benjamini_hochberg_per_metric: Optional[pulumi.Input[builtins.bool]] = None,
                 benjamini_hochberg_per_variant: Optional[pulumi.Input[builtins.bool]] = None,
                 benjamini_primary_metrics_only: Optional[pulumi.Input[builtins.bool]] = None,
                 bonferroni_correction: Optional[pulumi.Input[builtins.bool]] = None,
                 bonferroni_correction_per_metric: Optional[pulumi.Input[builtins.bool]] = None,
                 cohort_wait_until_end_to_include: Optional[pulumi.Input[builtins.bool]] = None,
                 cohorted_analysis_duration: Optional[pulumi.Input[builtins.int]] = None,
                 cohorted_metrics_mature_after_end: Optional[pulumi.Input[builtins.bool]] = None,
                 control_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 creator_email: Optional[pulumi.Input[builtins.str]] = None,
                 creator_id: Optional[pulumi.Input[builtins.str]] = None,
                 default_confidence_interval: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 duration: Optional[pulumi.Input[builtins.int]] = None,
                 fixed_analysis_duration: Optional[pulumi.Input[builtins.int]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentGroupArgs']]]] = None,
                 hypothesis: Optional[pulumi.Input[builtins.str]] = None,
                 id_type: Optional[pulumi.Input[builtins.str]] = None,
                 is_analysis_only: Optional[pulumi.Input[builtins.bool]] = None,
                 launched_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 layer_id: Optional[pulumi.Input[builtins.str]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentLinkArgs']]]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 primary_metric_tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 primary_metrics: Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentPrimaryMetricArgs']]]] = None,
                 scheduled_reload_hour: Optional[pulumi.Input[builtins.int]] = None,
                 scheduled_reload_type: Optional[pulumi.Input[builtins.str]] = None,
                 secondary_idtype: Optional[pulumi.Input[builtins.str]] = None,
                 secondary_metric_tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 secondary_metrics: Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentSecondaryMetricArgs']]]] = None,
                 sequential_testing: Optional[pulumi.Input[builtins.bool]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 target_apps: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 target_exposures: Optional[pulumi.Input[builtins.int]] = None,
                 targeting_gate_id: Optional[pulumi.Input[builtins.str]] = None,
                 team: Optional[pulumi.Input[builtins.str]] = None):
        """
        Input properties used for looking up and filtering Experiment resources.
        :param pulumi.Input[builtins.float] allocation: Percent of layer allocated to this experiment
        :param pulumi.Input[builtins.int] allocation_duration: Warehouse Native Only - Allocation duration in days
        :param pulumi.Input[builtins.str] analysis_end_time: Warehouse Native only - end time for analysis only experiments
        :param pulumi.Input[builtins.str] analytics_type: The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
        :param pulumi.Input[builtins.str] assignment_source_experiment_name: Name of the source experiment for assignment
        :param pulumi.Input[builtins.str] assignment_source_name: Source name of the assignment
        :param pulumi.Input[builtins.bool] benjamini_hochberg_per_metric: Is Benjamini-Hochberg procedure applied per metric?
        :param pulumi.Input[builtins.bool] benjamini_hochberg_per_variant: Is Benjamini-Hochberg procedure applied per variant?
        :param pulumi.Input[builtins.bool] benjamini_primary_metrics_only: Is Benjamini-Hochberg procedure applied for primary metrics only?
        :param pulumi.Input[builtins.bool] bonferroni_correction: Is Bonferroni correction applied per variant?
        :param pulumi.Input[builtins.bool] bonferroni_correction_per_metric: Is Bonferroni correction applied per metric?
        :param pulumi.Input[builtins.bool] cohort_wait_until_end_to_include: Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
        :param pulumi.Input[builtins.int] cohorted_analysis_duration: Warehouse Native Only - Cohorted analysis duration in days
        :param pulumi.Input[builtins.bool] cohorted_metrics_mature_after_end: Warehouse Native Only - Allow cohort metrics to mature after experiment end
        :param pulumi.Input[builtins.str] control_group_id: Optional control group ID
        :param pulumi.Input[builtins.str] creator_email: The email of the creator of this experiment
        :param pulumi.Input[builtins.str] creator_id: The Statsig ID of the creator of this experiment
        :param pulumi.Input[builtins.str] default_confidence_interval: Default error margin used for results
        :param pulumi.Input[builtins.str] description: A description of the new experiment
        :param pulumi.Input[builtins.int] duration: How long the experiment is expected to last in days
        :param pulumi.Input[builtins.int] fixed_analysis_duration: Fixed analysis duration in days
        :param pulumi.Input[Sequence[pulumi.Input['ExperimentGroupArgs']]] groups: The test groups for your experiment
        :param pulumi.Input[builtins.str] hypothesis: A statement that will be tested by this experiment
        :param pulumi.Input[builtins.str] id_type: The idType the experiment will be performed on
        :param pulumi.Input[builtins.bool] is_analysis_only: For Warehouse Native
        :param pulumi.Input[builtins.str] launched_group_id: ID of the launched group, null otherwise
        :param pulumi.Input[builtins.str] layer_id: Which layer to place the experiment into.
        :param pulumi.Input[Sequence[pulumi.Input['ExperimentLinkArgs']]] links: Links to relevant documentation or resources
        :param pulumi.Input[builtins.str] name: The name of the new experiment
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] primary_metric_tags: Primary metric tags for the experiment
        :param pulumi.Input[Sequence[pulumi.Input['ExperimentPrimaryMetricArgs']]] primary_metrics: Main metrics needed to evaluate your hypothesis
        :param pulumi.Input[builtins.int] scheduled_reload_hour: Warehouse Native only - UTC hour at which to run scheduled pulse loads
        :param pulumi.Input[builtins.str] scheduled_reload_type: Warehouse Native only - reload type for scheduled reloads
        :param pulumi.Input[builtins.str] secondary_idtype: The secondary ID type for the experiment used in WHN for ID resolution
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] secondary_metric_tags: Secondary metric tags for the experiment
        :param pulumi.Input[Sequence[pulumi.Input['ExperimentSecondaryMetricArgs']]] secondary_metrics: Additional metrics to monitor that might impact the analysis or final decision of the experiment
        :param pulumi.Input[builtins.bool] sequential_testing: Apply sequential testing?
        :param pulumi.Input[builtins.str] status: The current status of the experiment
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tags: Tags associated with the experiment
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] target_apps: Target apps assigned to this experiment
        :param pulumi.Input[builtins.int] target_exposures: Target exposures for the experiment
        :param pulumi.Input[builtins.str] targeting_gate_id: Restrict your experiment to users passing the selected feature gate
        :param pulumi.Input[builtins.str] team: Enterprise only
        """
        if allocation is not None:
            pulumi.set(__self__, "allocation", allocation)
        if allocation_duration is not None:
            pulumi.set(__self__, "allocation_duration", allocation_duration)
        if analysis_end_time is not None:
            pulumi.set(__self__, "analysis_end_time", analysis_end_time)
        if analytics_type is not None:
            pulumi.set(__self__, "analytics_type", analytics_type)
        if assignment_source_experiment_name is not None:
            pulumi.set(__self__, "assignment_source_experiment_name", assignment_source_experiment_name)
        if assignment_source_name is not None:
            pulumi.set(__self__, "assignment_source_name", assignment_source_name)
        if benjamini_hochberg_per_metric is not None:
            pulumi.set(__self__, "benjamini_hochberg_per_metric", benjamini_hochberg_per_metric)
        if benjamini_hochberg_per_variant is not None:
            pulumi.set(__self__, "benjamini_hochberg_per_variant", benjamini_hochberg_per_variant)
        if benjamini_primary_metrics_only is not None:
            pulumi.set(__self__, "benjamini_primary_metrics_only", benjamini_primary_metrics_only)
        if bonferroni_correction is not None:
            pulumi.set(__self__, "bonferroni_correction", bonferroni_correction)
        if bonferroni_correction_per_metric is not None:
            pulumi.set(__self__, "bonferroni_correction_per_metric", bonferroni_correction_per_metric)
        if cohort_wait_until_end_to_include is not None:
            pulumi.set(__self__, "cohort_wait_until_end_to_include", cohort_wait_until_end_to_include)
        if cohorted_analysis_duration is not None:
            pulumi.set(__self__, "cohorted_analysis_duration", cohorted_analysis_duration)
        if cohorted_metrics_mature_after_end is not None:
            pulumi.set(__self__, "cohorted_metrics_mature_after_end", cohorted_metrics_mature_after_end)
        if control_group_id is not None:
            pulumi.set(__self__, "control_group_id", control_group_id)
        if creator_email is not None:
            pulumi.set(__self__, "creator_email", creator_email)
        if creator_id is not None:
            pulumi.set(__self__, "creator_id", creator_id)
        if default_confidence_interval is not None:
            pulumi.set(__self__, "default_confidence_interval", default_confidence_interval)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if fixed_analysis_duration is not None:
            pulumi.set(__self__, "fixed_analysis_duration", fixed_analysis_duration)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if hypothesis is not None:
            pulumi.set(__self__, "hypothesis", hypothesis)
        if id_type is not None:
            pulumi.set(__self__, "id_type", id_type)
        if is_analysis_only is not None:
            pulumi.set(__self__, "is_analysis_only", is_analysis_only)
        if launched_group_id is not None:
            pulumi.set(__self__, "launched_group_id", launched_group_id)
        if layer_id is not None:
            pulumi.set(__self__, "layer_id", layer_id)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_metric_tags is not None:
            pulumi.set(__self__, "primary_metric_tags", primary_metric_tags)
        if primary_metrics is not None:
            pulumi.set(__self__, "primary_metrics", primary_metrics)
        if scheduled_reload_hour is not None:
            pulumi.set(__self__, "scheduled_reload_hour", scheduled_reload_hour)
        if scheduled_reload_type is not None:
            pulumi.set(__self__, "scheduled_reload_type", scheduled_reload_type)
        if secondary_idtype is not None:
            pulumi.set(__self__, "secondary_idtype", secondary_idtype)
        if secondary_metric_tags is not None:
            pulumi.set(__self__, "secondary_metric_tags", secondary_metric_tags)
        if secondary_metrics is not None:
            pulumi.set(__self__, "secondary_metrics", secondary_metrics)
        if sequential_testing is not None:
            pulumi.set(__self__, "sequential_testing", sequential_testing)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if target_apps is not None:
            pulumi.set(__self__, "target_apps", target_apps)
        if target_exposures is not None:
            pulumi.set(__self__, "target_exposures", target_exposures)
        if targeting_gate_id is not None:
            pulumi.set(__self__, "targeting_gate_id", targeting_gate_id)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter
    def allocation(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Percent of layer allocated to this experiment
        """
        return pulumi.get(self, "allocation")

    @allocation.setter
    def allocation(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "allocation", value)

    @property
    @pulumi.getter(name="allocationDuration")
    def allocation_duration(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Warehouse Native Only - Allocation duration in days
        """
        return pulumi.get(self, "allocation_duration")

    @allocation_duration.setter
    def allocation_duration(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "allocation_duration", value)

    @property
    @pulumi.getter(name="analysisEndTime")
    def analysis_end_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Warehouse Native only - end time for analysis only experiments
        """
        return pulumi.get(self, "analysis_end_time")

    @analysis_end_time.setter
    def analysis_end_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "analysis_end_time", value)

    @property
    @pulumi.getter(name="analyticsType")
    def analytics_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
        """
        return pulumi.get(self, "analytics_type")

    @analytics_type.setter
    def analytics_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "analytics_type", value)

    @property
    @pulumi.getter(name="assignmentSourceExperimentName")
    def assignment_source_experiment_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the source experiment for assignment
        """
        return pulumi.get(self, "assignment_source_experiment_name")

    @assignment_source_experiment_name.setter
    def assignment_source_experiment_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "assignment_source_experiment_name", value)

    @property
    @pulumi.getter(name="assignmentSourceName")
    def assignment_source_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Source name of the assignment
        """
        return pulumi.get(self, "assignment_source_name")

    @assignment_source_name.setter
    def assignment_source_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "assignment_source_name", value)

    @property
    @pulumi.getter(name="benjaminiHochbergPerMetric")
    def benjamini_hochberg_per_metric(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Is Benjamini-Hochberg procedure applied per metric?
        """
        return pulumi.get(self, "benjamini_hochberg_per_metric")

    @benjamini_hochberg_per_metric.setter
    def benjamini_hochberg_per_metric(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "benjamini_hochberg_per_metric", value)

    @property
    @pulumi.getter(name="benjaminiHochbergPerVariant")
    def benjamini_hochberg_per_variant(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Is Benjamini-Hochberg procedure applied per variant?
        """
        return pulumi.get(self, "benjamini_hochberg_per_variant")

    @benjamini_hochberg_per_variant.setter
    def benjamini_hochberg_per_variant(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "benjamini_hochberg_per_variant", value)

    @property
    @pulumi.getter(name="benjaminiPrimaryMetricsOnly")
    def benjamini_primary_metrics_only(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Is Benjamini-Hochberg procedure applied for primary metrics only?
        """
        return pulumi.get(self, "benjamini_primary_metrics_only")

    @benjamini_primary_metrics_only.setter
    def benjamini_primary_metrics_only(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "benjamini_primary_metrics_only", value)

    @property
    @pulumi.getter(name="bonferroniCorrection")
    def bonferroni_correction(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Is Bonferroni correction applied per variant?
        """
        return pulumi.get(self, "bonferroni_correction")

    @bonferroni_correction.setter
    def bonferroni_correction(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "bonferroni_correction", value)

    @property
    @pulumi.getter(name="bonferroniCorrectionPerMetric")
    def bonferroni_correction_per_metric(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Is Bonferroni correction applied per metric?
        """
        return pulumi.get(self, "bonferroni_correction_per_metric")

    @bonferroni_correction_per_metric.setter
    def bonferroni_correction_per_metric(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "bonferroni_correction_per_metric", value)

    @property
    @pulumi.getter(name="cohortWaitUntilEndToInclude")
    def cohort_wait_until_end_to_include(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
        """
        return pulumi.get(self, "cohort_wait_until_end_to_include")

    @cohort_wait_until_end_to_include.setter
    def cohort_wait_until_end_to_include(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "cohort_wait_until_end_to_include", value)

    @property
    @pulumi.getter(name="cohortedAnalysisDuration")
    def cohorted_analysis_duration(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Warehouse Native Only - Cohorted analysis duration in days
        """
        return pulumi.get(self, "cohorted_analysis_duration")

    @cohorted_analysis_duration.setter
    def cohorted_analysis_duration(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cohorted_analysis_duration", value)

    @property
    @pulumi.getter(name="cohortedMetricsMatureAfterEnd")
    def cohorted_metrics_mature_after_end(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Warehouse Native Only - Allow cohort metrics to mature after experiment end
        """
        return pulumi.get(self, "cohorted_metrics_mature_after_end")

    @cohorted_metrics_mature_after_end.setter
    def cohorted_metrics_mature_after_end(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "cohorted_metrics_mature_after_end", value)

    @property
    @pulumi.getter(name="controlGroupId")
    def control_group_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional control group ID
        """
        return pulumi.get(self, "control_group_id")

    @control_group_id.setter
    def control_group_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "control_group_id", value)

    @property
    @pulumi.getter(name="creatorEmail")
    def creator_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The email of the creator of this experiment
        """
        return pulumi.get(self, "creator_email")

    @creator_email.setter
    def creator_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "creator_email", value)

    @property
    @pulumi.getter(name="creatorId")
    def creator_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Statsig ID of the creator of this experiment
        """
        return pulumi.get(self, "creator_id")

    @creator_id.setter
    def creator_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "creator_id", value)

    @property
    @pulumi.getter(name="defaultConfidenceInterval")
    def default_confidence_interval(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default error margin used for results
        """
        return pulumi.get(self, "default_confidence_interval")

    @default_confidence_interval.setter
    def default_confidence_interval(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_confidence_interval", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A description of the new experiment
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        How long the experiment is expected to last in days
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="fixedAnalysisDuration")
    def fixed_analysis_duration(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Fixed analysis duration in days
        """
        return pulumi.get(self, "fixed_analysis_duration")

    @fixed_analysis_duration.setter
    def fixed_analysis_duration(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "fixed_analysis_duration", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentGroupArgs']]]]:
        """
        The test groups for your experiment
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentGroupArgs']]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def hypothesis(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A statement that will be tested by this experiment
        """
        return pulumi.get(self, "hypothesis")

    @hypothesis.setter
    def hypothesis(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "hypothesis", value)

    @property
    @pulumi.getter(name="idType")
    def id_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The idType the experiment will be performed on
        """
        return pulumi.get(self, "id_type")

    @id_type.setter
    def id_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id_type", value)

    @property
    @pulumi.getter(name="isAnalysisOnly")
    def is_analysis_only(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        For Warehouse Native
        """
        return pulumi.get(self, "is_analysis_only")

    @is_analysis_only.setter
    def is_analysis_only(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_analysis_only", value)

    @property
    @pulumi.getter(name="launchedGroupId")
    def launched_group_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID of the launched group, null otherwise
        """
        return pulumi.get(self, "launched_group_id")

    @launched_group_id.setter
    def launched_group_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "launched_group_id", value)

    @property
    @pulumi.getter(name="layerId")
    def layer_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Which layer to place the experiment into.
        """
        return pulumi.get(self, "layer_id")

    @layer_id.setter
    def layer_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "layer_id", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentLinkArgs']]]]:
        """
        Links to relevant documentation or resources
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the new experiment
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="primaryMetricTags")
    def primary_metric_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Primary metric tags for the experiment
        """
        return pulumi.get(self, "primary_metric_tags")

    @primary_metric_tags.setter
    def primary_metric_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "primary_metric_tags", value)

    @property
    @pulumi.getter(name="primaryMetrics")
    def primary_metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentPrimaryMetricArgs']]]]:
        """
        Main metrics needed to evaluate your hypothesis
        """
        return pulumi.get(self, "primary_metrics")

    @primary_metrics.setter
    def primary_metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentPrimaryMetricArgs']]]]):
        pulumi.set(self, "primary_metrics", value)

    @property
    @pulumi.getter(name="scheduledReloadHour")
    def scheduled_reload_hour(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Warehouse Native only - UTC hour at which to run scheduled pulse loads
        """
        return pulumi.get(self, "scheduled_reload_hour")

    @scheduled_reload_hour.setter
    def scheduled_reload_hour(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "scheduled_reload_hour", value)

    @property
    @pulumi.getter(name="scheduledReloadType")
    def scheduled_reload_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Warehouse Native only - reload type for scheduled reloads
        """
        return pulumi.get(self, "scheduled_reload_type")

    @scheduled_reload_type.setter
    def scheduled_reload_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "scheduled_reload_type", value)

    @property
    @pulumi.getter(name="secondaryIdtype")
    def secondary_idtype(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The secondary ID type for the experiment used in WHN for ID resolution
        """
        return pulumi.get(self, "secondary_idtype")

    @secondary_idtype.setter
    def secondary_idtype(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secondary_idtype", value)

    @property
    @pulumi.getter(name="secondaryMetricTags")
    def secondary_metric_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Secondary metric tags for the experiment
        """
        return pulumi.get(self, "secondary_metric_tags")

    @secondary_metric_tags.setter
    def secondary_metric_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "secondary_metric_tags", value)

    @property
    @pulumi.getter(name="secondaryMetrics")
    def secondary_metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentSecondaryMetricArgs']]]]:
        """
        Additional metrics to monitor that might impact the analysis or final decision of the experiment
        """
        return pulumi.get(self, "secondary_metrics")

    @secondary_metrics.setter
    def secondary_metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExperimentSecondaryMetricArgs']]]]):
        pulumi.set(self, "secondary_metrics", value)

    @property
    @pulumi.getter(name="sequentialTesting")
    def sequential_testing(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Apply sequential testing?
        """
        return pulumi.get(self, "sequential_testing")

    @sequential_testing.setter
    def sequential_testing(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "sequential_testing", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The current status of the experiment
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Tags associated with the experiment
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="targetApps")
    def target_apps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Target apps assigned to this experiment
        """
        return pulumi.get(self, "target_apps")

    @target_apps.setter
    def target_apps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "target_apps", value)

    @property
    @pulumi.getter(name="targetExposures")
    def target_exposures(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Target exposures for the experiment
        """
        return pulumi.get(self, "target_exposures")

    @target_exposures.setter
    def target_exposures(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "target_exposures", value)

    @property
    @pulumi.getter(name="targetingGateId")
    def targeting_gate_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Restrict your experiment to users passing the selected feature gate
        """
        return pulumi.get(self, "targeting_gate_id")

    @targeting_gate_id.setter
    def targeting_gate_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "targeting_gate_id", value)

    @property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Enterprise only
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "team", value)


@pulumi.type_token("statsig:index/experiment:Experiment")
class Experiment(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 allocation: Optional[pulumi.Input[builtins.float]] = None,
                 allocation_duration: Optional[pulumi.Input[builtins.int]] = None,
                 analysis_end_time: Optional[pulumi.Input[builtins.str]] = None,
                 analytics_type: Optional[pulumi.Input[builtins.str]] = None,
                 assignment_source_experiment_name: Optional[pulumi.Input[builtins.str]] = None,
                 assignment_source_name: Optional[pulumi.Input[builtins.str]] = None,
                 benjamini_hochberg_per_metric: Optional[pulumi.Input[builtins.bool]] = None,
                 benjamini_hochberg_per_variant: Optional[pulumi.Input[builtins.bool]] = None,
                 benjamini_primary_metrics_only: Optional[pulumi.Input[builtins.bool]] = None,
                 bonferroni_correction: Optional[pulumi.Input[builtins.bool]] = None,
                 bonferroni_correction_per_metric: Optional[pulumi.Input[builtins.bool]] = None,
                 cohort_wait_until_end_to_include: Optional[pulumi.Input[builtins.bool]] = None,
                 cohorted_analysis_duration: Optional[pulumi.Input[builtins.int]] = None,
                 cohorted_metrics_mature_after_end: Optional[pulumi.Input[builtins.bool]] = None,
                 control_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 creator_email: Optional[pulumi.Input[builtins.str]] = None,
                 creator_id: Optional[pulumi.Input[builtins.str]] = None,
                 default_confidence_interval: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 duration: Optional[pulumi.Input[builtins.int]] = None,
                 fixed_analysis_duration: Optional[pulumi.Input[builtins.int]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ExperimentGroupArgs', 'ExperimentGroupArgsDict']]]]] = None,
                 hypothesis: Optional[pulumi.Input[builtins.str]] = None,
                 id_type: Optional[pulumi.Input[builtins.str]] = None,
                 is_analysis_only: Optional[pulumi.Input[builtins.bool]] = None,
                 launched_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 layer_id: Optional[pulumi.Input[builtins.str]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ExperimentLinkArgs', 'ExperimentLinkArgsDict']]]]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 primary_metric_tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 primary_metrics: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ExperimentPrimaryMetricArgs', 'ExperimentPrimaryMetricArgsDict']]]]] = None,
                 scheduled_reload_hour: Optional[pulumi.Input[builtins.int]] = None,
                 scheduled_reload_type: Optional[pulumi.Input[builtins.str]] = None,
                 secondary_idtype: Optional[pulumi.Input[builtins.str]] = None,
                 secondary_metric_tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 secondary_metrics: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ExperimentSecondaryMetricArgs', 'ExperimentSecondaryMetricArgsDict']]]]] = None,
                 sequential_testing: Optional[pulumi.Input[builtins.bool]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 target_apps: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 target_exposures: Optional[pulumi.Input[builtins.int]] = None,
                 targeting_gate_id: Optional[pulumi.Input[builtins.str]] = None,
                 team: Optional[pulumi.Input[builtins.str]] = None,
                 __props__=None):
        """
        This resource allows you to configure experiments for your Statsig project.

        To learn more about experiments, see [Experiments Documentation](https://docs.statsig.com/experiments-plus/)

        To learn more about the API powering this resource, see [Experiments API Documentation](https://docs.statsig.com/console-api/experiments)

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[builtins.float] allocation: Percent of layer allocated to this experiment
        :param pulumi.Input[builtins.int] allocation_duration: Warehouse Native Only - Allocation duration in days
        :param pulumi.Input[builtins.str] analysis_end_time: Warehouse Native only - end time for analysis only experiments
        :param pulumi.Input[builtins.str] analytics_type: The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
        :param pulumi.Input[builtins.str] assignment_source_experiment_name: Name of the source experiment for assignment
        :param pulumi.Input[builtins.str] assignment_source_name: Source name of the assignment
        :param pulumi.Input[builtins.bool] benjamini_hochberg_per_metric: Is Benjamini-Hochberg procedure applied per metric?
        :param pulumi.Input[builtins.bool] benjamini_hochberg_per_variant: Is Benjamini-Hochberg procedure applied per variant?
        :param pulumi.Input[builtins.bool] benjamini_primary_metrics_only: Is Benjamini-Hochberg procedure applied for primary metrics only?
        :param pulumi.Input[builtins.bool] bonferroni_correction: Is Bonferroni correction applied per variant?
        :param pulumi.Input[builtins.bool] bonferroni_correction_per_metric: Is Bonferroni correction applied per metric?
        :param pulumi.Input[builtins.bool] cohort_wait_until_end_to_include: Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
        :param pulumi.Input[builtins.int] cohorted_analysis_duration: Warehouse Native Only - Cohorted analysis duration in days
        :param pulumi.Input[builtins.bool] cohorted_metrics_mature_after_end: Warehouse Native Only - Allow cohort metrics to mature after experiment end
        :param pulumi.Input[builtins.str] control_group_id: Optional control group ID
        :param pulumi.Input[builtins.str] creator_email: The email of the creator of this experiment
        :param pulumi.Input[builtins.str] creator_id: The Statsig ID of the creator of this experiment
        :param pulumi.Input[builtins.str] default_confidence_interval: Default error margin used for results
        :param pulumi.Input[builtins.str] description: A description of the new experiment
        :param pulumi.Input[builtins.int] duration: How long the experiment is expected to last in days
        :param pulumi.Input[builtins.int] fixed_analysis_duration: Fixed analysis duration in days
        :param pulumi.Input[Sequence[pulumi.Input[Union['ExperimentGroupArgs', 'ExperimentGroupArgsDict']]]] groups: The test groups for your experiment
        :param pulumi.Input[builtins.str] hypothesis: A statement that will be tested by this experiment
        :param pulumi.Input[builtins.str] id_type: The idType the experiment will be performed on
        :param pulumi.Input[builtins.bool] is_analysis_only: For Warehouse Native
        :param pulumi.Input[builtins.str] launched_group_id: ID of the launched group, null otherwise
        :param pulumi.Input[builtins.str] layer_id: Which layer to place the experiment into.
        :param pulumi.Input[Sequence[pulumi.Input[Union['ExperimentLinkArgs', 'ExperimentLinkArgsDict']]]] links: Links to relevant documentation or resources
        :param pulumi.Input[builtins.str] name: The name of the new experiment
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] primary_metric_tags: Primary metric tags for the experiment
        :param pulumi.Input[Sequence[pulumi.Input[Union['ExperimentPrimaryMetricArgs', 'ExperimentPrimaryMetricArgsDict']]]] primary_metrics: Main metrics needed to evaluate your hypothesis
        :param pulumi.Input[builtins.int] scheduled_reload_hour: Warehouse Native only - UTC hour at which to run scheduled pulse loads
        :param pulumi.Input[builtins.str] scheduled_reload_type: Warehouse Native only - reload type for scheduled reloads
        :param pulumi.Input[builtins.str] secondary_idtype: The secondary ID type for the experiment used in WHN for ID resolution
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] secondary_metric_tags: Secondary metric tags for the experiment
        :param pulumi.Input[Sequence[pulumi.Input[Union['ExperimentSecondaryMetricArgs', 'ExperimentSecondaryMetricArgsDict']]]] secondary_metrics: Additional metrics to monitor that might impact the analysis or final decision of the experiment
        :param pulumi.Input[builtins.bool] sequential_testing: Apply sequential testing?
        :param pulumi.Input[builtins.str] status: The current status of the experiment
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tags: Tags associated with the experiment
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] target_apps: Target apps assigned to this experiment
        :param pulumi.Input[builtins.int] target_exposures: Target exposures for the experiment
        :param pulumi.Input[builtins.str] targeting_gate_id: Restrict your experiment to users passing the selected feature gate
        :param pulumi.Input[builtins.str] team: Enterprise only
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: Optional[ExperimentArgs] = None,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        This resource allows you to configure experiments for your Statsig project.

        To learn more about experiments, see [Experiments Documentation](https://docs.statsig.com/experiments-plus/)

        To learn more about the API powering this resource, see [Experiments API Documentation](https://docs.statsig.com/console-api/experiments)

        :param str resource_name: The name of the resource.
        :param ExperimentArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ExperimentArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 allocation: Optional[pulumi.Input[builtins.float]] = None,
                 allocation_duration: Optional[pulumi.Input[builtins.int]] = None,
                 analysis_end_time: Optional[pulumi.Input[builtins.str]] = None,
                 analytics_type: Optional[pulumi.Input[builtins.str]] = None,
                 assignment_source_experiment_name: Optional[pulumi.Input[builtins.str]] = None,
                 assignment_source_name: Optional[pulumi.Input[builtins.str]] = None,
                 benjamini_hochberg_per_metric: Optional[pulumi.Input[builtins.bool]] = None,
                 benjamini_hochberg_per_variant: Optional[pulumi.Input[builtins.bool]] = None,
                 benjamini_primary_metrics_only: Optional[pulumi.Input[builtins.bool]] = None,
                 bonferroni_correction: Optional[pulumi.Input[builtins.bool]] = None,
                 bonferroni_correction_per_metric: Optional[pulumi.Input[builtins.bool]] = None,
                 cohort_wait_until_end_to_include: Optional[pulumi.Input[builtins.bool]] = None,
                 cohorted_analysis_duration: Optional[pulumi.Input[builtins.int]] = None,
                 cohorted_metrics_mature_after_end: Optional[pulumi.Input[builtins.bool]] = None,
                 control_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 creator_email: Optional[pulumi.Input[builtins.str]] = None,
                 creator_id: Optional[pulumi.Input[builtins.str]] = None,
                 default_confidence_interval: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 duration: Optional[pulumi.Input[builtins.int]] = None,
                 fixed_analysis_duration: Optional[pulumi.Input[builtins.int]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ExperimentGroupArgs', 'ExperimentGroupArgsDict']]]]] = None,
                 hypothesis: Optional[pulumi.Input[builtins.str]] = None,
                 id_type: Optional[pulumi.Input[builtins.str]] = None,
                 is_analysis_only: Optional[pulumi.Input[builtins.bool]] = None,
                 launched_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 layer_id: Optional[pulumi.Input[builtins.str]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ExperimentLinkArgs', 'ExperimentLinkArgsDict']]]]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 primary_metric_tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 primary_metrics: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ExperimentPrimaryMetricArgs', 'ExperimentPrimaryMetricArgsDict']]]]] = None,
                 scheduled_reload_hour: Optional[pulumi.Input[builtins.int]] = None,
                 scheduled_reload_type: Optional[pulumi.Input[builtins.str]] = None,
                 secondary_idtype: Optional[pulumi.Input[builtins.str]] = None,
                 secondary_metric_tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 secondary_metrics: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ExperimentSecondaryMetricArgs', 'ExperimentSecondaryMetricArgsDict']]]]] = None,
                 sequential_testing: Optional[pulumi.Input[builtins.bool]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 target_apps: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 target_exposures: Optional[pulumi.Input[builtins.int]] = None,
                 targeting_gate_id: Optional[pulumi.Input[builtins.str]] = None,
                 team: Optional[pulumi.Input[builtins.str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ExperimentArgs.__new__(ExperimentArgs)

            __props__.__dict__["allocation"] = allocation
            __props__.__dict__["allocation_duration"] = allocation_duration
            __props__.__dict__["analysis_end_time"] = analysis_end_time
            __props__.__dict__["analytics_type"] = analytics_type
            __props__.__dict__["assignment_source_experiment_name"] = assignment_source_experiment_name
            __props__.__dict__["assignment_source_name"] = assignment_source_name
            __props__.__dict__["benjamini_hochberg_per_metric"] = benjamini_hochberg_per_metric
            __props__.__dict__["benjamini_hochberg_per_variant"] = benjamini_hochberg_per_variant
            __props__.__dict__["benjamini_primary_metrics_only"] = benjamini_primary_metrics_only
            __props__.__dict__["bonferroni_correction"] = bonferroni_correction
            __props__.__dict__["bonferroni_correction_per_metric"] = bonferroni_correction_per_metric
            __props__.__dict__["cohort_wait_until_end_to_include"] = cohort_wait_until_end_to_include
            __props__.__dict__["cohorted_analysis_duration"] = cohorted_analysis_duration
            __props__.__dict__["cohorted_metrics_mature_after_end"] = cohorted_metrics_mature_after_end
            __props__.__dict__["control_group_id"] = control_group_id
            __props__.__dict__["creator_email"] = creator_email
            __props__.__dict__["creator_id"] = creator_id
            __props__.__dict__["default_confidence_interval"] = default_confidence_interval
            __props__.__dict__["description"] = description
            __props__.__dict__["duration"] = duration
            __props__.__dict__["fixed_analysis_duration"] = fixed_analysis_duration
            __props__.__dict__["groups"] = groups
            __props__.__dict__["hypothesis"] = hypothesis
            __props__.__dict__["id_type"] = id_type
            __props__.__dict__["is_analysis_only"] = is_analysis_only
            __props__.__dict__["launched_group_id"] = launched_group_id
            __props__.__dict__["layer_id"] = layer_id
            __props__.__dict__["links"] = links
            __props__.__dict__["name"] = name
            __props__.__dict__["primary_metric_tags"] = primary_metric_tags
            __props__.__dict__["primary_metrics"] = primary_metrics
            __props__.__dict__["scheduled_reload_hour"] = scheduled_reload_hour
            __props__.__dict__["scheduled_reload_type"] = scheduled_reload_type
            __props__.__dict__["secondary_idtype"] = secondary_idtype
            __props__.__dict__["secondary_metric_tags"] = secondary_metric_tags
            __props__.__dict__["secondary_metrics"] = secondary_metrics
            __props__.__dict__["sequential_testing"] = sequential_testing
            __props__.__dict__["status"] = status
            __props__.__dict__["tags"] = tags
            __props__.__dict__["target_apps"] = target_apps
            __props__.__dict__["target_exposures"] = target_exposures
            __props__.__dict__["targeting_gate_id"] = targeting_gate_id
            __props__.__dict__["team"] = team
        super(Experiment, __self__).__init__(
            'statsig:index/experiment:Experiment',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            allocation: Optional[pulumi.Input[builtins.float]] = None,
            allocation_duration: Optional[pulumi.Input[builtins.int]] = None,
            analysis_end_time: Optional[pulumi.Input[builtins.str]] = None,
            analytics_type: Optional[pulumi.Input[builtins.str]] = None,
            assignment_source_experiment_name: Optional[pulumi.Input[builtins.str]] = None,
            assignment_source_name: Optional[pulumi.Input[builtins.str]] = None,
            benjamini_hochberg_per_metric: Optional[pulumi.Input[builtins.bool]] = None,
            benjamini_hochberg_per_variant: Optional[pulumi.Input[builtins.bool]] = None,
            benjamini_primary_metrics_only: Optional[pulumi.Input[builtins.bool]] = None,
            bonferroni_correction: Optional[pulumi.Input[builtins.bool]] = None,
            bonferroni_correction_per_metric: Optional[pulumi.Input[builtins.bool]] = None,
            cohort_wait_until_end_to_include: Optional[pulumi.Input[builtins.bool]] = None,
            cohorted_analysis_duration: Optional[pulumi.Input[builtins.int]] = None,
            cohorted_metrics_mature_after_end: Optional[pulumi.Input[builtins.bool]] = None,
            control_group_id: Optional[pulumi.Input[builtins.str]] = None,
            creator_email: Optional[pulumi.Input[builtins.str]] = None,
            creator_id: Optional[pulumi.Input[builtins.str]] = None,
            default_confidence_interval: Optional[pulumi.Input[builtins.str]] = None,
            description: Optional[pulumi.Input[builtins.str]] = None,
            duration: Optional[pulumi.Input[builtins.int]] = None,
            fixed_analysis_duration: Optional[pulumi.Input[builtins.int]] = None,
            groups: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ExperimentGroupArgs', 'ExperimentGroupArgsDict']]]]] = None,
            hypothesis: Optional[pulumi.Input[builtins.str]] = None,
            id_type: Optional[pulumi.Input[builtins.str]] = None,
            is_analysis_only: Optional[pulumi.Input[builtins.bool]] = None,
            launched_group_id: Optional[pulumi.Input[builtins.str]] = None,
            layer_id: Optional[pulumi.Input[builtins.str]] = None,
            links: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ExperimentLinkArgs', 'ExperimentLinkArgsDict']]]]] = None,
            name: Optional[pulumi.Input[builtins.str]] = None,
            primary_metric_tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            primary_metrics: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ExperimentPrimaryMetricArgs', 'ExperimentPrimaryMetricArgsDict']]]]] = None,
            scheduled_reload_hour: Optional[pulumi.Input[builtins.int]] = None,
            scheduled_reload_type: Optional[pulumi.Input[builtins.str]] = None,
            secondary_idtype: Optional[pulumi.Input[builtins.str]] = None,
            secondary_metric_tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            secondary_metrics: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ExperimentSecondaryMetricArgs', 'ExperimentSecondaryMetricArgsDict']]]]] = None,
            sequential_testing: Optional[pulumi.Input[builtins.bool]] = None,
            status: Optional[pulumi.Input[builtins.str]] = None,
            tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            target_apps: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
            target_exposures: Optional[pulumi.Input[builtins.int]] = None,
            targeting_gate_id: Optional[pulumi.Input[builtins.str]] = None,
            team: Optional[pulumi.Input[builtins.str]] = None) -> 'Experiment':
        """
        Get an existing Experiment resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[builtins.float] allocation: Percent of layer allocated to this experiment
        :param pulumi.Input[builtins.int] allocation_duration: Warehouse Native Only - Allocation duration in days
        :param pulumi.Input[builtins.str] analysis_end_time: Warehouse Native only - end time for analysis only experiments
        :param pulumi.Input[builtins.str] analytics_type: The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
        :param pulumi.Input[builtins.str] assignment_source_experiment_name: Name of the source experiment for assignment
        :param pulumi.Input[builtins.str] assignment_source_name: Source name of the assignment
        :param pulumi.Input[builtins.bool] benjamini_hochberg_per_metric: Is Benjamini-Hochberg procedure applied per metric?
        :param pulumi.Input[builtins.bool] benjamini_hochberg_per_variant: Is Benjamini-Hochberg procedure applied per variant?
        :param pulumi.Input[builtins.bool] benjamini_primary_metrics_only: Is Benjamini-Hochberg procedure applied for primary metrics only?
        :param pulumi.Input[builtins.bool] bonferroni_correction: Is Bonferroni correction applied per variant?
        :param pulumi.Input[builtins.bool] bonferroni_correction_per_metric: Is Bonferroni correction applied per metric?
        :param pulumi.Input[builtins.bool] cohort_wait_until_end_to_include: Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
        :param pulumi.Input[builtins.int] cohorted_analysis_duration: Warehouse Native Only - Cohorted analysis duration in days
        :param pulumi.Input[builtins.bool] cohorted_metrics_mature_after_end: Warehouse Native Only - Allow cohort metrics to mature after experiment end
        :param pulumi.Input[builtins.str] control_group_id: Optional control group ID
        :param pulumi.Input[builtins.str] creator_email: The email of the creator of this experiment
        :param pulumi.Input[builtins.str] creator_id: The Statsig ID of the creator of this experiment
        :param pulumi.Input[builtins.str] default_confidence_interval: Default error margin used for results
        :param pulumi.Input[builtins.str] description: A description of the new experiment
        :param pulumi.Input[builtins.int] duration: How long the experiment is expected to last in days
        :param pulumi.Input[builtins.int] fixed_analysis_duration: Fixed analysis duration in days
        :param pulumi.Input[Sequence[pulumi.Input[Union['ExperimentGroupArgs', 'ExperimentGroupArgsDict']]]] groups: The test groups for your experiment
        :param pulumi.Input[builtins.str] hypothesis: A statement that will be tested by this experiment
        :param pulumi.Input[builtins.str] id_type: The idType the experiment will be performed on
        :param pulumi.Input[builtins.bool] is_analysis_only: For Warehouse Native
        :param pulumi.Input[builtins.str] launched_group_id: ID of the launched group, null otherwise
        :param pulumi.Input[builtins.str] layer_id: Which layer to place the experiment into.
        :param pulumi.Input[Sequence[pulumi.Input[Union['ExperimentLinkArgs', 'ExperimentLinkArgsDict']]]] links: Links to relevant documentation or resources
        :param pulumi.Input[builtins.str] name: The name of the new experiment
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] primary_metric_tags: Primary metric tags for the experiment
        :param pulumi.Input[Sequence[pulumi.Input[Union['ExperimentPrimaryMetricArgs', 'ExperimentPrimaryMetricArgsDict']]]] primary_metrics: Main metrics needed to evaluate your hypothesis
        :param pulumi.Input[builtins.int] scheduled_reload_hour: Warehouse Native only - UTC hour at which to run scheduled pulse loads
        :param pulumi.Input[builtins.str] scheduled_reload_type: Warehouse Native only - reload type for scheduled reloads
        :param pulumi.Input[builtins.str] secondary_idtype: The secondary ID type for the experiment used in WHN for ID resolution
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] secondary_metric_tags: Secondary metric tags for the experiment
        :param pulumi.Input[Sequence[pulumi.Input[Union['ExperimentSecondaryMetricArgs', 'ExperimentSecondaryMetricArgsDict']]]] secondary_metrics: Additional metrics to monitor that might impact the analysis or final decision of the experiment
        :param pulumi.Input[builtins.bool] sequential_testing: Apply sequential testing?
        :param pulumi.Input[builtins.str] status: The current status of the experiment
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tags: Tags associated with the experiment
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] target_apps: Target apps assigned to this experiment
        :param pulumi.Input[builtins.int] target_exposures: Target exposures for the experiment
        :param pulumi.Input[builtins.str] targeting_gate_id: Restrict your experiment to users passing the selected feature gate
        :param pulumi.Input[builtins.str] team: Enterprise only
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _ExperimentState.__new__(_ExperimentState)

        __props__.__dict__["allocation"] = allocation
        __props__.__dict__["allocation_duration"] = allocation_duration
        __props__.__dict__["analysis_end_time"] = analysis_end_time
        __props__.__dict__["analytics_type"] = analytics_type
        __props__.__dict__["assignment_source_experiment_name"] = assignment_source_experiment_name
        __props__.__dict__["assignment_source_name"] = assignment_source_name
        __props__.__dict__["benjamini_hochberg_per_metric"] = benjamini_hochberg_per_metric
        __props__.__dict__["benjamini_hochberg_per_variant"] = benjamini_hochberg_per_variant
        __props__.__dict__["benjamini_primary_metrics_only"] = benjamini_primary_metrics_only
        __props__.__dict__["bonferroni_correction"] = bonferroni_correction
        __props__.__dict__["bonferroni_correction_per_metric"] = bonferroni_correction_per_metric
        __props__.__dict__["cohort_wait_until_end_to_include"] = cohort_wait_until_end_to_include
        __props__.__dict__["cohorted_analysis_duration"] = cohorted_analysis_duration
        __props__.__dict__["cohorted_metrics_mature_after_end"] = cohorted_metrics_mature_after_end
        __props__.__dict__["control_group_id"] = control_group_id
        __props__.__dict__["creator_email"] = creator_email
        __props__.__dict__["creator_id"] = creator_id
        __props__.__dict__["default_confidence_interval"] = default_confidence_interval
        __props__.__dict__["description"] = description
        __props__.__dict__["duration"] = duration
        __props__.__dict__["fixed_analysis_duration"] = fixed_analysis_duration
        __props__.__dict__["groups"] = groups
        __props__.__dict__["hypothesis"] = hypothesis
        __props__.__dict__["id_type"] = id_type
        __props__.__dict__["is_analysis_only"] = is_analysis_only
        __props__.__dict__["launched_group_id"] = launched_group_id
        __props__.__dict__["layer_id"] = layer_id
        __props__.__dict__["links"] = links
        __props__.__dict__["name"] = name
        __props__.__dict__["primary_metric_tags"] = primary_metric_tags
        __props__.__dict__["primary_metrics"] = primary_metrics
        __props__.__dict__["scheduled_reload_hour"] = scheduled_reload_hour
        __props__.__dict__["scheduled_reload_type"] = scheduled_reload_type
        __props__.__dict__["secondary_idtype"] = secondary_idtype
        __props__.__dict__["secondary_metric_tags"] = secondary_metric_tags
        __props__.__dict__["secondary_metrics"] = secondary_metrics
        __props__.__dict__["sequential_testing"] = sequential_testing
        __props__.__dict__["status"] = status
        __props__.__dict__["tags"] = tags
        __props__.__dict__["target_apps"] = target_apps
        __props__.__dict__["target_exposures"] = target_exposures
        __props__.__dict__["targeting_gate_id"] = targeting_gate_id
        __props__.__dict__["team"] = team
        return Experiment(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def allocation(self) -> pulumi.Output[builtins.float]:
        """
        Percent of layer allocated to this experiment
        """
        return pulumi.get(self, "allocation")

    @property
    @pulumi.getter(name="allocationDuration")
    def allocation_duration(self) -> pulumi.Output[builtins.int]:
        """
        Warehouse Native Only - Allocation duration in days
        """
        return pulumi.get(self, "allocation_duration")

    @property
    @pulumi.getter(name="analysisEndTime")
    def analysis_end_time(self) -> pulumi.Output[builtins.str]:
        """
        Warehouse Native only - end time for analysis only experiments
        """
        return pulumi.get(self, "analysis_end_time")

    @property
    @pulumi.getter(name="analyticsType")
    def analytics_type(self) -> pulumi.Output[builtins.str]:
        """
        The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
        """
        return pulumi.get(self, "analytics_type")

    @property
    @pulumi.getter(name="assignmentSourceExperimentName")
    def assignment_source_experiment_name(self) -> pulumi.Output[builtins.str]:
        """
        Name of the source experiment for assignment
        """
        return pulumi.get(self, "assignment_source_experiment_name")

    @property
    @pulumi.getter(name="assignmentSourceName")
    def assignment_source_name(self) -> pulumi.Output[builtins.str]:
        """
        Source name of the assignment
        """
        return pulumi.get(self, "assignment_source_name")

    @property
    @pulumi.getter(name="benjaminiHochbergPerMetric")
    def benjamini_hochberg_per_metric(self) -> pulumi.Output[builtins.bool]:
        """
        Is Benjamini-Hochberg procedure applied per metric?
        """
        return pulumi.get(self, "benjamini_hochberg_per_metric")

    @property
    @pulumi.getter(name="benjaminiHochbergPerVariant")
    def benjamini_hochberg_per_variant(self) -> pulumi.Output[builtins.bool]:
        """
        Is Benjamini-Hochberg procedure applied per variant?
        """
        return pulumi.get(self, "benjamini_hochberg_per_variant")

    @property
    @pulumi.getter(name="benjaminiPrimaryMetricsOnly")
    def benjamini_primary_metrics_only(self) -> pulumi.Output[builtins.bool]:
        """
        Is Benjamini-Hochberg procedure applied for primary metrics only?
        """
        return pulumi.get(self, "benjamini_primary_metrics_only")

    @property
    @pulumi.getter(name="bonferroniCorrection")
    def bonferroni_correction(self) -> pulumi.Output[builtins.bool]:
        """
        Is Bonferroni correction applied per variant?
        """
        return pulumi.get(self, "bonferroni_correction")

    @property
    @pulumi.getter(name="bonferroniCorrectionPerMetric")
    def bonferroni_correction_per_metric(self) -> pulumi.Output[builtins.bool]:
        """
        Is Bonferroni correction applied per metric?
        """
        return pulumi.get(self, "bonferroni_correction_per_metric")

    @property
    @pulumi.getter(name="cohortWaitUntilEndToInclude")
    def cohort_wait_until_end_to_include(self) -> pulumi.Output[builtins.bool]:
        """
        Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
        """
        return pulumi.get(self, "cohort_wait_until_end_to_include")

    @property
    @pulumi.getter(name="cohortedAnalysisDuration")
    def cohorted_analysis_duration(self) -> pulumi.Output[builtins.int]:
        """
        Warehouse Native Only - Cohorted analysis duration in days
        """
        return pulumi.get(self, "cohorted_analysis_duration")

    @property
    @pulumi.getter(name="cohortedMetricsMatureAfterEnd")
    def cohorted_metrics_mature_after_end(self) -> pulumi.Output[builtins.bool]:
        """
        Warehouse Native Only - Allow cohort metrics to mature after experiment end
        """
        return pulumi.get(self, "cohorted_metrics_mature_after_end")

    @property
    @pulumi.getter(name="controlGroupId")
    def control_group_id(self) -> pulumi.Output[builtins.str]:
        """
        Optional control group ID
        """
        return pulumi.get(self, "control_group_id")

    @property
    @pulumi.getter(name="creatorEmail")
    def creator_email(self) -> pulumi.Output[builtins.str]:
        """
        The email of the creator of this experiment
        """
        return pulumi.get(self, "creator_email")

    @property
    @pulumi.getter(name="creatorId")
    def creator_id(self) -> pulumi.Output[builtins.str]:
        """
        The Statsig ID of the creator of this experiment
        """
        return pulumi.get(self, "creator_id")

    @property
    @pulumi.getter(name="defaultConfidenceInterval")
    def default_confidence_interval(self) -> pulumi.Output[builtins.str]:
        """
        Default error margin used for results
        """
        return pulumi.get(self, "default_confidence_interval")

    @property
    @pulumi.getter
    def description(self) -> pulumi.Output[builtins.str]:
        """
        A description of the new experiment
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Output[builtins.int]:
        """
        How long the experiment is expected to last in days
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="fixedAnalysisDuration")
    def fixed_analysis_duration(self) -> pulumi.Output[builtins.int]:
        """
        Fixed analysis duration in days
        """
        return pulumi.get(self, "fixed_analysis_duration")

    @property
    @pulumi.getter
    def groups(self) -> pulumi.Output[Sequence['outputs.ExperimentGroup']]:
        """
        The test groups for your experiment
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def hypothesis(self) -> pulumi.Output[builtins.str]:
        """
        A statement that will be tested by this experiment
        """
        return pulumi.get(self, "hypothesis")

    @property
    @pulumi.getter(name="idType")
    def id_type(self) -> pulumi.Output[builtins.str]:
        """
        The idType the experiment will be performed on
        """
        return pulumi.get(self, "id_type")

    @property
    @pulumi.getter(name="isAnalysisOnly")
    def is_analysis_only(self) -> pulumi.Output[builtins.bool]:
        """
        For Warehouse Native
        """
        return pulumi.get(self, "is_analysis_only")

    @property
    @pulumi.getter(name="launchedGroupId")
    def launched_group_id(self) -> pulumi.Output[builtins.str]:
        """
        ID of the launched group, null otherwise
        """
        return pulumi.get(self, "launched_group_id")

    @property
    @pulumi.getter(name="layerId")
    def layer_id(self) -> pulumi.Output[builtins.str]:
        """
        Which layer to place the experiment into.
        """
        return pulumi.get(self, "layer_id")

    @property
    @pulumi.getter
    def links(self) -> pulumi.Output[Sequence['outputs.ExperimentLink']]:
        """
        Links to relevant documentation or resources
        """
        return pulumi.get(self, "links")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[builtins.str]:
        """
        The name of the new experiment
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryMetricTags")
    def primary_metric_tags(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        Primary metric tags for the experiment
        """
        return pulumi.get(self, "primary_metric_tags")

    @property
    @pulumi.getter(name="primaryMetrics")
    def primary_metrics(self) -> pulumi.Output[Sequence['outputs.ExperimentPrimaryMetric']]:
        """
        Main metrics needed to evaluate your hypothesis
        """
        return pulumi.get(self, "primary_metrics")

    @property
    @pulumi.getter(name="scheduledReloadHour")
    def scheduled_reload_hour(self) -> pulumi.Output[builtins.int]:
        """
        Warehouse Native only - UTC hour at which to run scheduled pulse loads
        """
        return pulumi.get(self, "scheduled_reload_hour")

    @property
    @pulumi.getter(name="scheduledReloadType")
    def scheduled_reload_type(self) -> pulumi.Output[builtins.str]:
        """
        Warehouse Native only - reload type for scheduled reloads
        """
        return pulumi.get(self, "scheduled_reload_type")

    @property
    @pulumi.getter(name="secondaryIdtype")
    def secondary_idtype(self) -> pulumi.Output[builtins.str]:
        """
        The secondary ID type for the experiment used in WHN for ID resolution
        """
        return pulumi.get(self, "secondary_idtype")

    @property
    @pulumi.getter(name="secondaryMetricTags")
    def secondary_metric_tags(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        Secondary metric tags for the experiment
        """
        return pulumi.get(self, "secondary_metric_tags")

    @property
    @pulumi.getter(name="secondaryMetrics")
    def secondary_metrics(self) -> pulumi.Output[Sequence['outputs.ExperimentSecondaryMetric']]:
        """
        Additional metrics to monitor that might impact the analysis or final decision of the experiment
        """
        return pulumi.get(self, "secondary_metrics")

    @property
    @pulumi.getter(name="sequentialTesting")
    def sequential_testing(self) -> pulumi.Output[builtins.bool]:
        """
        Apply sequential testing?
        """
        return pulumi.get(self, "sequential_testing")

    @property
    @pulumi.getter
    def status(self) -> pulumi.Output[builtins.str]:
        """
        The current status of the experiment
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        Tags associated with the experiment
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="targetApps")
    def target_apps(self) -> pulumi.Output[Sequence[builtins.str]]:
        """
        Target apps assigned to this experiment
        """
        return pulumi.get(self, "target_apps")

    @property
    @pulumi.getter(name="targetExposures")
    def target_exposures(self) -> pulumi.Output[builtins.int]:
        """
        Target exposures for the experiment
        """
        return pulumi.get(self, "target_exposures")

    @property
    @pulumi.getter(name="targetingGateId")
    def targeting_gate_id(self) -> pulumi.Output[builtins.str]:
        """
        Restrict your experiment to users passing the selected feature gate
        """
        return pulumi.get(self, "targeting_gate_id")

    @property
    @pulumi.getter
    def team(self) -> pulumi.Output[builtins.str]:
        """
        Enterprise only
        """
        return pulumi.get(self, "team")

