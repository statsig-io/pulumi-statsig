# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'EntityPropertyIdTypeMappingArgs',
    'EntityPropertyIdTypeMappingArgsDict',
    'EntityPropertyOwnerArgs',
    'EntityPropertyOwnerArgsDict',
    'ExperimentGroupArgs',
    'ExperimentGroupArgsDict',
    'ExperimentLinkArgs',
    'ExperimentLinkArgsDict',
    'ExperimentPrimaryMetricArgs',
    'ExperimentPrimaryMetricArgsDict',
    'ExperimentSecondaryMetricArgs',
    'ExperimentSecondaryMetricArgsDict',
    'GateMonitoringMetricArgs',
    'GateMonitoringMetricArgsDict',
    'GateRuleArgs',
    'GateRuleArgsDict',
    'GateRuleConditionArgs',
    'GateRuleConditionArgsDict',
    'GateRuleReturnValueArgs',
    'GateRuleReturnValueArgsDict',
    'MetricFunnelEventListArgs',
    'MetricFunnelEventListArgsDict',
    'MetricMetricComponentMetricArgs',
    'MetricMetricComponentMetricArgsDict',
    'MetricMetricEventArgs',
    'MetricMetricEventArgsDict',
    'MetricMetricEventCriteriaArgs',
    'MetricMetricEventCriteriaArgsDict',
    'MetricSourceCustomFieldMappingArgs',
    'MetricSourceCustomFieldMappingArgsDict',
    'MetricSourceIdTypeMappingArgs',
    'MetricSourceIdTypeMappingArgsDict',
    'MetricSourceOwnerArgs',
    'MetricSourceOwnerArgsDict',
    'MetricWarehouseNativeArgs',
    'MetricWarehouseNativeArgsDict',
    'MetricWarehouseNativeCriteriaArgs',
    'MetricWarehouseNativeCriteriaArgsDict',
    'MetricWarehouseNativeDenominatorCriteriaArgs',
    'MetricWarehouseNativeDenominatorCriteriaArgsDict',
    'MetricWarehouseNativeFunnelEventArgs',
    'MetricWarehouseNativeFunnelEventArgsDict',
    'MetricWarehouseNativeFunnelEventCriteriaArgs',
    'MetricWarehouseNativeFunnelEventCriteriaArgsDict',
]

MYPY = False

if not MYPY:
    class EntityPropertyIdTypeMappingArgsDict(TypedDict):
        column: pulumi.Input[builtins.str]
        """
        Column name linked to the ID.
        """
        statsig_unit_id: pulumi.Input[builtins.str]
        """
        ID for the Statsig unit.
        """
elif False:
    EntityPropertyIdTypeMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntityPropertyIdTypeMappingArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[builtins.str],
                 statsig_unit_id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] column: Column name linked to the ID.
        :param pulumi.Input[builtins.str] statsig_unit_id: ID for the Statsig unit.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "statsig_unit_id", statsig_unit_id)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input[builtins.str]:
        """
        Column name linked to the ID.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="statsigUnitId")
    def statsig_unit_id(self) -> pulumi.Input[builtins.str]:
        """
        ID for the Statsig unit.
        """
        return pulumi.get(self, "statsig_unit_id")

    @statsig_unit_id.setter
    def statsig_unit_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "statsig_unit_id", value)


if not MYPY:
    class EntityPropertyOwnerArgsDict(TypedDict):
        owner_email: NotRequired[pulumi.Input[builtins.str]]
        """
        The email of the owner. This field is optional.
        """
        owner_id: NotRequired[pulumi.Input[builtins.str]]
        """
        ID of the owner
        """
        owner_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the owner. This field is optional.
        """
        owner_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of the owner (e.g., SDK_KEY or USER)
        """
elif False:
    EntityPropertyOwnerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntityPropertyOwnerArgs:
    def __init__(__self__, *,
                 owner_email: Optional[pulumi.Input[builtins.str]] = None,
                 owner_id: Optional[pulumi.Input[builtins.str]] = None,
                 owner_name: Optional[pulumi.Input[builtins.str]] = None,
                 owner_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] owner_email: The email of the owner. This field is optional.
        :param pulumi.Input[builtins.str] owner_id: ID of the owner
        :param pulumi.Input[builtins.str] owner_name: The name of the owner. This field is optional.
        :param pulumi.Input[builtins.str] owner_type: Type of the owner (e.g., SDK_KEY or USER)
        """
        if owner_email is not None:
            pulumi.set(__self__, "owner_email", owner_email)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if owner_name is not None:
            pulumi.set(__self__, "owner_name", owner_name)
        if owner_type is not None:
            pulumi.set(__self__, "owner_type", owner_type)

    @property
    @pulumi.getter(name="ownerEmail")
    def owner_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The email of the owner. This field is optional.
        """
        return pulumi.get(self, "owner_email")

    @owner_email.setter
    def owner_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "owner_email", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID of the owner
        """
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="ownerName")
    def owner_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the owner. This field is optional.
        """
        return pulumi.get(self, "owner_name")

    @owner_name.setter
    def owner_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "owner_name", value)

    @property
    @pulumi.getter(name="ownerType")
    def owner_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of the owner (e.g., SDK_KEY or USER)
        """
        return pulumi.get(self, "owner_type")

    @owner_type.setter
    def owner_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "owner_type", value)


if not MYPY:
    class ExperimentGroupArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        parameter_values: pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]
        size: pulumi.Input[builtins.float]
        description: NotRequired[pulumi.Input[builtins.str]]
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        foreign_group_id: NotRequired[pulumi.Input[builtins.str]]
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ExperimentGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExperimentGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 parameter_values: pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]],
                 size: pulumi.Input[builtins.float],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 foreign_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parameter_values", parameter_values)
        pulumi.set(__self__, "size", size)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if foreign_group_id is not None:
            pulumi.set(__self__, "foreign_group_id", foreign_group_id)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="parameterValues")
    def parameter_values(self) -> pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "parameter_values")

    @parameter_values.setter
    def parameter_values(self, value: pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]):
        pulumi.set(self, "parameter_values", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[builtins.float]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="foreignGroupId")
    def foreign_group_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "foreign_group_id")

    @foreign_group_id.setter
    def foreign_group_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "foreign_group_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ExperimentLinkArgsDict(TypedDict):
        url: pulumi.Input[builtins.str]
        """
        The URL of the link
        """
        title: NotRequired[pulumi.Input[builtins.str]]
        """
        The title of the link
        """
elif False:
    ExperimentLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExperimentLinkArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[builtins.str],
                 title: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] url: The URL of the link
        :param pulumi.Input[builtins.str] title: The title of the link
        """
        pulumi.set(__self__, "url", url)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[builtins.str]:
        """
        The URL of the link
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The title of the link
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class ExperimentPrimaryMetricArgsDict(TypedDict):
        direction: NotRequired[pulumi.Input[builtins.str]]
        hypothesized_value: NotRequired[pulumi.Input[builtins.float]]
        name: NotRequired[pulumi.Input[builtins.str]]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ExperimentPrimaryMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExperimentPrimaryMetricArgs:
    def __init__(__self__, *,
                 direction: Optional[pulumi.Input[builtins.str]] = None,
                 hypothesized_value: Optional[pulumi.Input[builtins.float]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if hypothesized_value is not None:
            pulumi.set(__self__, "hypothesized_value", hypothesized_value)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter(name="hypothesizedValue")
    def hypothesized_value(self) -> Optional[pulumi.Input[builtins.float]]:
        return pulumi.get(self, "hypothesized_value")

    @hypothesized_value.setter
    def hypothesized_value(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "hypothesized_value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ExperimentSecondaryMetricArgsDict(TypedDict):
        direction: NotRequired[pulumi.Input[builtins.str]]
        hypothesized_value: NotRequired[pulumi.Input[builtins.float]]
        name: NotRequired[pulumi.Input[builtins.str]]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ExperimentSecondaryMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExperimentSecondaryMetricArgs:
    def __init__(__self__, *,
                 direction: Optional[pulumi.Input[builtins.str]] = None,
                 hypothesized_value: Optional[pulumi.Input[builtins.float]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if hypothesized_value is not None:
            pulumi.set(__self__, "hypothesized_value", hypothesized_value)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter(name="hypothesizedValue")
    def hypothesized_value(self) -> Optional[pulumi.Input[builtins.float]]:
        return pulumi.get(self, "hypothesized_value")

    @hypothesized_value.setter
    def hypothesized_value(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "hypothesized_value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GateMonitoringMetricArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    GateMonitoringMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GateMonitoringMetricArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GateRuleArgsDict(TypedDict):
        conditions: pulumi.Input[Sequence[pulumi.Input['GateRuleConditionArgsDict']]]
        """
        An array of Condition objects.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of this rule.
        """
        pass_percentage: pulumi.Input[builtins.float]
        """
        Of the users that meet the conditions of this rule, what percent should return true.
        """
        base_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
        """
        environments: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The environments this rule is enabled for.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The Statsig ID of this rule.
        """
        return_value: NotRequired[pulumi.Input['GateRuleReturnValueArgsDict']]
        """
        The return value of the rule.
        """
elif False:
    GateRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GateRuleArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['GateRuleConditionArgs']]],
                 name: pulumi.Input[builtins.str],
                 pass_percentage: pulumi.Input[builtins.float],
                 base_id: Optional[pulumi.Input[builtins.str]] = None,
                 environments: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 return_value: Optional[pulumi.Input['GateRuleReturnValueArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GateRuleConditionArgs']]] conditions: An array of Condition objects.
        :param pulumi.Input[builtins.str] name: The name of this rule.
        :param pulumi.Input[builtins.float] pass_percentage: Of the users that meet the conditions of this rule, what percent should return true.
        :param pulumi.Input[builtins.str] base_id: The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] environments: The environments this rule is enabled for.
        :param pulumi.Input[builtins.str] id: The Statsig ID of this rule.
        :param pulumi.Input['GateRuleReturnValueArgs'] return_value: The return value of the rule.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pass_percentage", pass_percentage)
        if base_id is not None:
            pulumi.set(__self__, "base_id", base_id)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if return_value is not None:
            pulumi.set(__self__, "return_value", return_value)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['GateRuleConditionArgs']]]:
        """
        An array of Condition objects.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['GateRuleConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of this rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="passPercentage")
    def pass_percentage(self) -> pulumi.Input[builtins.float]:
        """
        Of the users that meet the conditions of this rule, what percent should return true.
        """
        return pulumi.get(self, "pass_percentage")

    @pass_percentage.setter
    def pass_percentage(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "pass_percentage", value)

    @property
    @pulumi.getter(name="baseId")
    def base_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The base ID of this rule, i.e. without any added metadata. Will remain the exact same throughout
        """
        return pulumi.get(self, "base_id")

    @base_id.setter
    def base_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "base_id", value)

    @property
    @pulumi.getter
    def environments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The environments this rule is enabled for.
        """
        return pulumi.get(self, "environments")

    @environments.setter
    def environments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "environments", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Statsig ID of this rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="returnValue")
    def return_value(self) -> Optional[pulumi.Input['GateRuleReturnValueArgs']]:
        """
        The return value of the rule.
        """
        return pulumi.get(self, "return_value")

    @return_value.setter
    def return_value(self, value: Optional[pulumi.Input['GateRuleReturnValueArgs']]):
        pulumi.set(self, "return_value", value)


if not MYPY:
    class GateRuleConditionArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        custom_id: NotRequired[pulumi.Input[builtins.str]]
        field: NotRequired[pulumi.Input[builtins.str]]
        operator: NotRequired[pulumi.Input[builtins.str]]
        target_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    GateRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GateRuleConditionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 custom_id: Optional[pulumi.Input[builtins.str]] = None,
                 field: Optional[pulumi.Input[builtins.str]] = None,
                 operator: Optional[pulumi.Input[builtins.str]] = None,
                 target_values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        pulumi.set(__self__, "type", type)
        if custom_id is not None:
            pulumi.set(__self__, "custom_id", custom_id)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if target_values is not None:
            pulumi.set(__self__, "target_values", target_values)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="customId")
    def custom_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "custom_id")

    @custom_id.setter
    def custom_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_id", value)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="targetValues")
    def target_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "target_values")

    @target_values.setter
    def target_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "target_values", value)


if not MYPY:
    class GateRuleReturnValueArgsDict(TypedDict):
        pass
elif False:
    GateRuleReturnValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GateRuleReturnValueArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class MetricFunnelEventListArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The name of the funnel event used in the metric.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of funnel event, specifying how the event is tracked.
        """
elif False:
    MetricFunnelEventListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricFunnelEventListArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] name: The name of the funnel event used in the metric.
        :param pulumi.Input[builtins.str] type: The type of funnel event, specifying how the event is tracked.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the funnel event used in the metric.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of funnel event, specifying how the event is tracked.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MetricMetricComponentMetricArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        type: pulumi.Input[builtins.str]
elif False:
    MetricMetricComponentMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricMetricComponentMetricArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MetricMetricEventArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The name of the metric event.
        """
        criterias: NotRequired[pulumi.Input[Sequence[pulumi.Input['MetricMetricEventCriteriaArgsDict']]]]
        """
        Filtering criteria for the metric event, including conditions and values to refine the event data.
        """
        metadata_key: NotRequired[pulumi.Input[builtins.str]]
        """
        The key for associated metadata, if applicable.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of metric event. Allowed values include: count, count_distinct, value, and metadata.
        """
elif False:
    MetricMetricEventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricMetricEventArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 criterias: Optional[pulumi.Input[Sequence[pulumi.Input['MetricMetricEventCriteriaArgs']]]] = None,
                 metadata_key: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: The name of the metric event.
        :param pulumi.Input[Sequence[pulumi.Input['MetricMetricEventCriteriaArgs']]] criterias: Filtering criteria for the metric event, including conditions and values to refine the event data.
        :param pulumi.Input[builtins.str] metadata_key: The key for associated metadata, if applicable.
        :param pulumi.Input[builtins.str] type: The type of metric event. Allowed values include: count, count_distinct, value, and metadata.
        """
        pulumi.set(__self__, "name", name)
        if criterias is not None:
            pulumi.set(__self__, "criterias", criterias)
        if metadata_key is not None:
            pulumi.set(__self__, "metadata_key", metadata_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the metric event.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def criterias(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricMetricEventCriteriaArgs']]]]:
        """
        Filtering criteria for the metric event, including conditions and values to refine the event data.
        """
        return pulumi.get(self, "criterias")

    @criterias.setter
    def criterias(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricMetricEventCriteriaArgs']]]]):
        pulumi.set(self, "criterias", value)

    @property
    @pulumi.getter(name="metadataKey")
    def metadata_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The key for associated metadata, if applicable.
        """
        return pulumi.get(self, "metadata_key")

    @metadata_key.setter
    def metadata_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "metadata_key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of metric event. Allowed values include: count, count_distinct, value, and metadata.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MetricMetricEventCriteriaArgsDict(TypedDict):
        condition: pulumi.Input[builtins.str]
        """
        sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        """
        type: pulumi.Input[builtins.str]
        """
        Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        """
        column: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional column specifying which data attribute to filter on.
        """
        null_vacuous_override: NotRequired[pulumi.Input[builtins.bool]]
        """
        If true, overrides null values in criterion evaluation.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional array of values for the criterion to match against.
        """
elif False:
    MetricMetricEventCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricMetricEventCriteriaArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 column: Optional[pulumi.Input[builtins.str]] = None,
                 null_vacuous_override: Optional[pulumi.Input[builtins.bool]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] condition: sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        :param pulumi.Input[builtins.str] type: Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        :param pulumi.Input[builtins.str] column: Optional column specifying which data attribute to filter on.
        :param pulumi.Input[builtins.bool] null_vacuous_override: If true, overrides null values in criterion evaluation.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] values: Optional array of values for the criterion to match against.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "type", type)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if null_vacuous_override is not None:
            pulumi.set(__self__, "null_vacuous_override", null_vacuous_override)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[builtins.str]:
        """
        sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional column specifying which data attribute to filter on.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="nullVacuousOverride")
    def null_vacuous_override(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If true, overrides null values in criterion evaluation.
        """
        return pulumi.get(self, "null_vacuous_override")

    @null_vacuous_override.setter
    def null_vacuous_override(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "null_vacuous_override", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional array of values for the criterion to match against.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MetricSourceCustomFieldMappingArgsDict(TypedDict):
        formula: pulumi.Input[builtins.str]
        """
        The formula or expression used to compute the custom field value.
        """
        key: pulumi.Input[builtins.str]
        """
        The identifier for the custom field mapping.
        """
elif False:
    MetricSourceCustomFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricSourceCustomFieldMappingArgs:
    def __init__(__self__, *,
                 formula: pulumi.Input[builtins.str],
                 key: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] formula: The formula or expression used to compute the custom field value.
        :param pulumi.Input[builtins.str] key: The identifier for the custom field mapping.
        """
        pulumi.set(__self__, "formula", formula)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def formula(self) -> pulumi.Input[builtins.str]:
        """
        The formula or expression used to compute the custom field value.
        """
        return pulumi.get(self, "formula")

    @formula.setter
    def formula(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "formula", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        The identifier for the custom field mapping.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class MetricSourceIdTypeMappingArgsDict(TypedDict):
        column: pulumi.Input[builtins.str]
        """
        The corresponding column name in the source that relates to the Statsig unit ID.
        """
        statsig_unit_id: pulumi.Input[builtins.str]
        """
        The identifier mapping for Statsig units.
        """
elif False:
    MetricSourceIdTypeMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricSourceIdTypeMappingArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[builtins.str],
                 statsig_unit_id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] column: The corresponding column name in the source that relates to the Statsig unit ID.
        :param pulumi.Input[builtins.str] statsig_unit_id: The identifier mapping for Statsig units.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "statsig_unit_id", statsig_unit_id)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input[builtins.str]:
        """
        The corresponding column name in the source that relates to the Statsig unit ID.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="statsigUnitId")
    def statsig_unit_id(self) -> pulumi.Input[builtins.str]:
        """
        The identifier mapping for Statsig units.
        """
        return pulumi.get(self, "statsig_unit_id")

    @statsig_unit_id.setter
    def statsig_unit_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "statsig_unit_id", value)


if not MYPY:
    class MetricSourceOwnerArgsDict(TypedDict):
        owner_email: NotRequired[pulumi.Input[builtins.str]]
        """
        The email of the owner. This field is optional.
        """
        owner_id: NotRequired[pulumi.Input[builtins.str]]
        """
        ID of the owner
        """
        owner_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the owner. This field is optional.
        """
        owner_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of the owner (e.g., SDK_KEY or USER)
        """
elif False:
    MetricSourceOwnerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricSourceOwnerArgs:
    def __init__(__self__, *,
                 owner_email: Optional[pulumi.Input[builtins.str]] = None,
                 owner_id: Optional[pulumi.Input[builtins.str]] = None,
                 owner_name: Optional[pulumi.Input[builtins.str]] = None,
                 owner_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] owner_email: The email of the owner. This field is optional.
        :param pulumi.Input[builtins.str] owner_id: ID of the owner
        :param pulumi.Input[builtins.str] owner_name: The name of the owner. This field is optional.
        :param pulumi.Input[builtins.str] owner_type: Type of the owner (e.g., SDK_KEY or USER)
        """
        if owner_email is not None:
            pulumi.set(__self__, "owner_email", owner_email)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if owner_name is not None:
            pulumi.set(__self__, "owner_name", owner_name)
        if owner_type is not None:
            pulumi.set(__self__, "owner_type", owner_type)

    @property
    @pulumi.getter(name="ownerEmail")
    def owner_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The email of the owner. This field is optional.
        """
        return pulumi.get(self, "owner_email")

    @owner_email.setter
    def owner_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "owner_email", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID of the owner
        """
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="ownerName")
    def owner_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the owner. This field is optional.
        """
        return pulumi.get(self, "owner_name")

    @owner_name.setter
    def owner_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "owner_name", value)

    @property
    @pulumi.getter(name="ownerType")
    def owner_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of the owner (e.g., SDK_KEY or USER)
        """
        return pulumi.get(self, "owner_type")

    @owner_type.setter
    def owner_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "owner_type", value)


if not MYPY:
    class MetricWarehouseNativeArgsDict(TypedDict):
        aggregation: NotRequired[pulumi.Input[builtins.str]]
        """
        Allowed: count┃sum┃mean┃daily*participation┃ratio┃funnel┃count*distinct┃percentile
        """
        allow_null_ratio_denominator: NotRequired[pulumi.Input[builtins.bool]]
        """
        Include units which do not have a denominator. Only applicable to ratios.
        """
        cap: NotRequired[pulumi.Input[builtins.float]]
        """
        Maximum cap for metric values.
        """
        criterias: NotRequired[pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeCriteriaArgsDict']]]]
        """
        Filtering criteria for the metric source
        """
        cuped_attribution_window: NotRequired[pulumi.Input[builtins.float]]
        """
        Attribution window for CUPED adjustments in days.
        """
        custom_roll_up_end: NotRequired[pulumi.Input[builtins.float]]
        """
        Custom end date for rollup in days since exposure.
        """
        custom_roll_up_start: NotRequired[pulumi.Input[builtins.float]]
        """
        Custom start date for rollup in days since exposure.
        """
        denominator_aggregation: NotRequired[pulumi.Input[builtins.str]]
        """
        Allowed: count┃sum┃mean┃daily*participation┃ratio┃funnel┃count*distinct┃percentile
        """
        denominator_criterias: NotRequired[pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeDenominatorCriteriaArgsDict']]]]
        """
        Filtering criteria for the denominator metric source, if this metric is a ratio
        """
        denominator_custom_rollup_end: NotRequired[pulumi.Input[builtins.float]]
        """
        Custom end date for rollup in days since exposure.
        """
        denominator_custom_rollup_start: NotRequired[pulumi.Input[builtins.float]]
        """
        Custom start date for rollup in days since exposure.
        """
        denominator_metric_source_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the metric source for the denominator.
        """
        denominator_rollup_time_window: NotRequired[pulumi.Input[builtins.str]]
        """
        Time window for the denominator metric. Specify "custom" for a custom window.
        """
        denominator_value_column: NotRequired[pulumi.Input[builtins.str]]
        """
        Column name for the denominator’s value.
        """
        funnel_calculation_window: NotRequired[pulumi.Input[builtins.float]]
        """
        Duration for counting funnel events in days.
        """
        funnel_count_distinct: NotRequired[pulumi.Input[builtins.str]]
        """
        Allowed: users┃sessions for distinct count method in funnel events.
        """
        funnel_events: NotRequired[pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeFunnelEventArgsDict']]]]
        """
        List of funnel events with associated criteria and identifiers.
        """
        funnel_start_criteria: NotRequired[pulumi.Input[builtins.str]]
        """
        Allowed: start_event┃exposure to determine funnel start criteria.
        """
        metric_bake_days: NotRequired[pulumi.Input[builtins.float]]
        """
        Number of days for metric baking; specify duration for analysis.
        """
        metric_dimension_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specify metadata columns for breaking down metric analysis.
        """
        metric_source_name: NotRequired[pulumi.Input[builtins.str]]
        """
        For Count, Sum, Mean, User Count aggregation types: the name of metric source
        """
        numerator_aggregation: NotRequired[pulumi.Input[builtins.str]]
        """
        Aggregation type for numerator; Allowed: count┃sum┃mean┃daily*participation┃ratio┃funnel┃count*distinct┃percentile.
        """
        only_include_users_with_conversion_event: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag to include only users with a conversion event in the metric.
        """
        percentile: NotRequired[pulumi.Input[builtins.float]]
        """
        Percentile value for statistical calculations.
        """
        rollup_time_window: NotRequired[pulumi.Input[builtins.str]]
        """
        General time window for rollup; can specify custom settings.
        """
        value_column: NotRequired[pulumi.Input[builtins.str]]
        """
        Column name representing the metric’s value.
        """
        value_threshold: NotRequired[pulumi.Input[builtins.float]]
        """
        Threshold value for filtering metrics.
        """
        wait_for_cohort_window: NotRequired[pulumi.Input[builtins.bool]]
        winsorization_high: NotRequired[pulumi.Input[builtins.float]]
        """
        High threshold for winsorization; must be between 0 and 1.
        """
        winsorization_low: NotRequired[pulumi.Input[builtins.float]]
        """
        Low threshold for winsorization; must be between 0 and 1.
        """
elif False:
    MetricWarehouseNativeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricWarehouseNativeArgs:
    def __init__(__self__, *,
                 aggregation: Optional[pulumi.Input[builtins.str]] = None,
                 allow_null_ratio_denominator: Optional[pulumi.Input[builtins.bool]] = None,
                 cap: Optional[pulumi.Input[builtins.float]] = None,
                 criterias: Optional[pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeCriteriaArgs']]]] = None,
                 cuped_attribution_window: Optional[pulumi.Input[builtins.float]] = None,
                 custom_roll_up_end: Optional[pulumi.Input[builtins.float]] = None,
                 custom_roll_up_start: Optional[pulumi.Input[builtins.float]] = None,
                 denominator_aggregation: Optional[pulumi.Input[builtins.str]] = None,
                 denominator_criterias: Optional[pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeDenominatorCriteriaArgs']]]] = None,
                 denominator_custom_rollup_end: Optional[pulumi.Input[builtins.float]] = None,
                 denominator_custom_rollup_start: Optional[pulumi.Input[builtins.float]] = None,
                 denominator_metric_source_name: Optional[pulumi.Input[builtins.str]] = None,
                 denominator_rollup_time_window: Optional[pulumi.Input[builtins.str]] = None,
                 denominator_value_column: Optional[pulumi.Input[builtins.str]] = None,
                 funnel_calculation_window: Optional[pulumi.Input[builtins.float]] = None,
                 funnel_count_distinct: Optional[pulumi.Input[builtins.str]] = None,
                 funnel_events: Optional[pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeFunnelEventArgs']]]] = None,
                 funnel_start_criteria: Optional[pulumi.Input[builtins.str]] = None,
                 metric_bake_days: Optional[pulumi.Input[builtins.float]] = None,
                 metric_dimension_columns: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 metric_source_name: Optional[pulumi.Input[builtins.str]] = None,
                 numerator_aggregation: Optional[pulumi.Input[builtins.str]] = None,
                 only_include_users_with_conversion_event: Optional[pulumi.Input[builtins.bool]] = None,
                 percentile: Optional[pulumi.Input[builtins.float]] = None,
                 rollup_time_window: Optional[pulumi.Input[builtins.str]] = None,
                 value_column: Optional[pulumi.Input[builtins.str]] = None,
                 value_threshold: Optional[pulumi.Input[builtins.float]] = None,
                 wait_for_cohort_window: Optional[pulumi.Input[builtins.bool]] = None,
                 winsorization_high: Optional[pulumi.Input[builtins.float]] = None,
                 winsorization_low: Optional[pulumi.Input[builtins.float]] = None):
        """
        :param pulumi.Input[builtins.str] aggregation: Allowed: count┃sum┃mean┃daily*participation┃ratio┃funnel┃count*distinct┃percentile
        :param pulumi.Input[builtins.bool] allow_null_ratio_denominator: Include units which do not have a denominator. Only applicable to ratios.
        :param pulumi.Input[builtins.float] cap: Maximum cap for metric values.
        :param pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeCriteriaArgs']]] criterias: Filtering criteria for the metric source
        :param pulumi.Input[builtins.float] cuped_attribution_window: Attribution window for CUPED adjustments in days.
        :param pulumi.Input[builtins.float] custom_roll_up_end: Custom end date for rollup in days since exposure.
        :param pulumi.Input[builtins.float] custom_roll_up_start: Custom start date for rollup in days since exposure.
        :param pulumi.Input[builtins.str] denominator_aggregation: Allowed: count┃sum┃mean┃daily*participation┃ratio┃funnel┃count*distinct┃percentile
        :param pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeDenominatorCriteriaArgs']]] denominator_criterias: Filtering criteria for the denominator metric source, if this metric is a ratio
        :param pulumi.Input[builtins.float] denominator_custom_rollup_end: Custom end date for rollup in days since exposure.
        :param pulumi.Input[builtins.float] denominator_custom_rollup_start: Custom start date for rollup in days since exposure.
        :param pulumi.Input[builtins.str] denominator_metric_source_name: Name of the metric source for the denominator.
        :param pulumi.Input[builtins.str] denominator_rollup_time_window: Time window for the denominator metric. Specify "custom" for a custom window.
        :param pulumi.Input[builtins.str] denominator_value_column: Column name for the denominator’s value.
        :param pulumi.Input[builtins.float] funnel_calculation_window: Duration for counting funnel events in days.
        :param pulumi.Input[builtins.str] funnel_count_distinct: Allowed: users┃sessions for distinct count method in funnel events.
        :param pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeFunnelEventArgs']]] funnel_events: List of funnel events with associated criteria and identifiers.
        :param pulumi.Input[builtins.str] funnel_start_criteria: Allowed: start_event┃exposure to determine funnel start criteria.
        :param pulumi.Input[builtins.float] metric_bake_days: Number of days for metric baking; specify duration for analysis.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] metric_dimension_columns: Specify metadata columns for breaking down metric analysis.
        :param pulumi.Input[builtins.str] metric_source_name: For Count, Sum, Mean, User Count aggregation types: the name of metric source
        :param pulumi.Input[builtins.str] numerator_aggregation: Aggregation type for numerator; Allowed: count┃sum┃mean┃daily*participation┃ratio┃funnel┃count*distinct┃percentile.
        :param pulumi.Input[builtins.bool] only_include_users_with_conversion_event: Flag to include only users with a conversion event in the metric.
        :param pulumi.Input[builtins.float] percentile: Percentile value for statistical calculations.
        :param pulumi.Input[builtins.str] rollup_time_window: General time window for rollup; can specify custom settings.
        :param pulumi.Input[builtins.str] value_column: Column name representing the metric’s value.
        :param pulumi.Input[builtins.float] value_threshold: Threshold value for filtering metrics.
        :param pulumi.Input[builtins.float] winsorization_high: High threshold for winsorization; must be between 0 and 1.
        :param pulumi.Input[builtins.float] winsorization_low: Low threshold for winsorization; must be between 0 and 1.
        """
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if allow_null_ratio_denominator is not None:
            pulumi.set(__self__, "allow_null_ratio_denominator", allow_null_ratio_denominator)
        if cap is not None:
            pulumi.set(__self__, "cap", cap)
        if criterias is not None:
            pulumi.set(__self__, "criterias", criterias)
        if cuped_attribution_window is not None:
            pulumi.set(__self__, "cuped_attribution_window", cuped_attribution_window)
        if custom_roll_up_end is not None:
            pulumi.set(__self__, "custom_roll_up_end", custom_roll_up_end)
        if custom_roll_up_start is not None:
            pulumi.set(__self__, "custom_roll_up_start", custom_roll_up_start)
        if denominator_aggregation is not None:
            pulumi.set(__self__, "denominator_aggregation", denominator_aggregation)
        if denominator_criterias is not None:
            pulumi.set(__self__, "denominator_criterias", denominator_criterias)
        if denominator_custom_rollup_end is not None:
            pulumi.set(__self__, "denominator_custom_rollup_end", denominator_custom_rollup_end)
        if denominator_custom_rollup_start is not None:
            pulumi.set(__self__, "denominator_custom_rollup_start", denominator_custom_rollup_start)
        if denominator_metric_source_name is not None:
            pulumi.set(__self__, "denominator_metric_source_name", denominator_metric_source_name)
        if denominator_rollup_time_window is not None:
            pulumi.set(__self__, "denominator_rollup_time_window", denominator_rollup_time_window)
        if denominator_value_column is not None:
            pulumi.set(__self__, "denominator_value_column", denominator_value_column)
        if funnel_calculation_window is not None:
            pulumi.set(__self__, "funnel_calculation_window", funnel_calculation_window)
        if funnel_count_distinct is not None:
            pulumi.set(__self__, "funnel_count_distinct", funnel_count_distinct)
        if funnel_events is not None:
            pulumi.set(__self__, "funnel_events", funnel_events)
        if funnel_start_criteria is not None:
            pulumi.set(__self__, "funnel_start_criteria", funnel_start_criteria)
        if metric_bake_days is not None:
            pulumi.set(__self__, "metric_bake_days", metric_bake_days)
        if metric_dimension_columns is not None:
            pulumi.set(__self__, "metric_dimension_columns", metric_dimension_columns)
        if metric_source_name is not None:
            pulumi.set(__self__, "metric_source_name", metric_source_name)
        if numerator_aggregation is not None:
            pulumi.set(__self__, "numerator_aggregation", numerator_aggregation)
        if only_include_users_with_conversion_event is not None:
            pulumi.set(__self__, "only_include_users_with_conversion_event", only_include_users_with_conversion_event)
        if percentile is not None:
            pulumi.set(__self__, "percentile", percentile)
        if rollup_time_window is not None:
            pulumi.set(__self__, "rollup_time_window", rollup_time_window)
        if value_column is not None:
            pulumi.set(__self__, "value_column", value_column)
        if value_threshold is not None:
            pulumi.set(__self__, "value_threshold", value_threshold)
        if wait_for_cohort_window is not None:
            pulumi.set(__self__, "wait_for_cohort_window", wait_for_cohort_window)
        if winsorization_high is not None:
            pulumi.set(__self__, "winsorization_high", winsorization_high)
        if winsorization_low is not None:
            pulumi.set(__self__, "winsorization_low", winsorization_low)

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Allowed: count┃sum┃mean┃daily*participation┃ratio┃funnel┃count*distinct┃percentile
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter(name="allowNullRatioDenominator")
    def allow_null_ratio_denominator(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Include units which do not have a denominator. Only applicable to ratios.
        """
        return pulumi.get(self, "allow_null_ratio_denominator")

    @allow_null_ratio_denominator.setter
    def allow_null_ratio_denominator(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_null_ratio_denominator", value)

    @property
    @pulumi.getter
    def cap(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Maximum cap for metric values.
        """
        return pulumi.get(self, "cap")

    @cap.setter
    def cap(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "cap", value)

    @property
    @pulumi.getter
    def criterias(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeCriteriaArgs']]]]:
        """
        Filtering criteria for the metric source
        """
        return pulumi.get(self, "criterias")

    @criterias.setter
    def criterias(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeCriteriaArgs']]]]):
        pulumi.set(self, "criterias", value)

    @property
    @pulumi.getter(name="cupedAttributionWindow")
    def cuped_attribution_window(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Attribution window for CUPED adjustments in days.
        """
        return pulumi.get(self, "cuped_attribution_window")

    @cuped_attribution_window.setter
    def cuped_attribution_window(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "cuped_attribution_window", value)

    @property
    @pulumi.getter(name="customRollUpEnd")
    def custom_roll_up_end(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Custom end date for rollup in days since exposure.
        """
        return pulumi.get(self, "custom_roll_up_end")

    @custom_roll_up_end.setter
    def custom_roll_up_end(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "custom_roll_up_end", value)

    @property
    @pulumi.getter(name="customRollUpStart")
    def custom_roll_up_start(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Custom start date for rollup in days since exposure.
        """
        return pulumi.get(self, "custom_roll_up_start")

    @custom_roll_up_start.setter
    def custom_roll_up_start(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "custom_roll_up_start", value)

    @property
    @pulumi.getter(name="denominatorAggregation")
    def denominator_aggregation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Allowed: count┃sum┃mean┃daily*participation┃ratio┃funnel┃count*distinct┃percentile
        """
        return pulumi.get(self, "denominator_aggregation")

    @denominator_aggregation.setter
    def denominator_aggregation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "denominator_aggregation", value)

    @property
    @pulumi.getter(name="denominatorCriterias")
    def denominator_criterias(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeDenominatorCriteriaArgs']]]]:
        """
        Filtering criteria for the denominator metric source, if this metric is a ratio
        """
        return pulumi.get(self, "denominator_criterias")

    @denominator_criterias.setter
    def denominator_criterias(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeDenominatorCriteriaArgs']]]]):
        pulumi.set(self, "denominator_criterias", value)

    @property
    @pulumi.getter(name="denominatorCustomRollupEnd")
    def denominator_custom_rollup_end(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Custom end date for rollup in days since exposure.
        """
        return pulumi.get(self, "denominator_custom_rollup_end")

    @denominator_custom_rollup_end.setter
    def denominator_custom_rollup_end(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "denominator_custom_rollup_end", value)

    @property
    @pulumi.getter(name="denominatorCustomRollupStart")
    def denominator_custom_rollup_start(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Custom start date for rollup in days since exposure.
        """
        return pulumi.get(self, "denominator_custom_rollup_start")

    @denominator_custom_rollup_start.setter
    def denominator_custom_rollup_start(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "denominator_custom_rollup_start", value)

    @property
    @pulumi.getter(name="denominatorMetricSourceName")
    def denominator_metric_source_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the metric source for the denominator.
        """
        return pulumi.get(self, "denominator_metric_source_name")

    @denominator_metric_source_name.setter
    def denominator_metric_source_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "denominator_metric_source_name", value)

    @property
    @pulumi.getter(name="denominatorRollupTimeWindow")
    def denominator_rollup_time_window(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time window for the denominator metric. Specify "custom" for a custom window.
        """
        return pulumi.get(self, "denominator_rollup_time_window")

    @denominator_rollup_time_window.setter
    def denominator_rollup_time_window(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "denominator_rollup_time_window", value)

    @property
    @pulumi.getter(name="denominatorValueColumn")
    def denominator_value_column(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Column name for the denominator’s value.
        """
        return pulumi.get(self, "denominator_value_column")

    @denominator_value_column.setter
    def denominator_value_column(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "denominator_value_column", value)

    @property
    @pulumi.getter(name="funnelCalculationWindow")
    def funnel_calculation_window(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Duration for counting funnel events in days.
        """
        return pulumi.get(self, "funnel_calculation_window")

    @funnel_calculation_window.setter
    def funnel_calculation_window(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "funnel_calculation_window", value)

    @property
    @pulumi.getter(name="funnelCountDistinct")
    def funnel_count_distinct(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Allowed: users┃sessions for distinct count method in funnel events.
        """
        return pulumi.get(self, "funnel_count_distinct")

    @funnel_count_distinct.setter
    def funnel_count_distinct(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "funnel_count_distinct", value)

    @property
    @pulumi.getter(name="funnelEvents")
    def funnel_events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeFunnelEventArgs']]]]:
        """
        List of funnel events with associated criteria and identifiers.
        """
        return pulumi.get(self, "funnel_events")

    @funnel_events.setter
    def funnel_events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeFunnelEventArgs']]]]):
        pulumi.set(self, "funnel_events", value)

    @property
    @pulumi.getter(name="funnelStartCriteria")
    def funnel_start_criteria(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Allowed: start_event┃exposure to determine funnel start criteria.
        """
        return pulumi.get(self, "funnel_start_criteria")

    @funnel_start_criteria.setter
    def funnel_start_criteria(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "funnel_start_criteria", value)

    @property
    @pulumi.getter(name="metricBakeDays")
    def metric_bake_days(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Number of days for metric baking; specify duration for analysis.
        """
        return pulumi.get(self, "metric_bake_days")

    @metric_bake_days.setter
    def metric_bake_days(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "metric_bake_days", value)

    @property
    @pulumi.getter(name="metricDimensionColumns")
    def metric_dimension_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specify metadata columns for breaking down metric analysis.
        """
        return pulumi.get(self, "metric_dimension_columns")

    @metric_dimension_columns.setter
    def metric_dimension_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "metric_dimension_columns", value)

    @property
    @pulumi.getter(name="metricSourceName")
    def metric_source_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        For Count, Sum, Mean, User Count aggregation types: the name of metric source
        """
        return pulumi.get(self, "metric_source_name")

    @metric_source_name.setter
    def metric_source_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "metric_source_name", value)

    @property
    @pulumi.getter(name="numeratorAggregation")
    def numerator_aggregation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Aggregation type for numerator; Allowed: count┃sum┃mean┃daily*participation┃ratio┃funnel┃count*distinct┃percentile.
        """
        return pulumi.get(self, "numerator_aggregation")

    @numerator_aggregation.setter
    def numerator_aggregation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "numerator_aggregation", value)

    @property
    @pulumi.getter(name="onlyIncludeUsersWithConversionEvent")
    def only_include_users_with_conversion_event(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to include only users with a conversion event in the metric.
        """
        return pulumi.get(self, "only_include_users_with_conversion_event")

    @only_include_users_with_conversion_event.setter
    def only_include_users_with_conversion_event(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "only_include_users_with_conversion_event", value)

    @property
    @pulumi.getter
    def percentile(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Percentile value for statistical calculations.
        """
        return pulumi.get(self, "percentile")

    @percentile.setter
    def percentile(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "percentile", value)

    @property
    @pulumi.getter(name="rollupTimeWindow")
    def rollup_time_window(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        General time window for rollup; can specify custom settings.
        """
        return pulumi.get(self, "rollup_time_window")

    @rollup_time_window.setter
    def rollup_time_window(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "rollup_time_window", value)

    @property
    @pulumi.getter(name="valueColumn")
    def value_column(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Column name representing the metric’s value.
        """
        return pulumi.get(self, "value_column")

    @value_column.setter
    def value_column(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value_column", value)

    @property
    @pulumi.getter(name="valueThreshold")
    def value_threshold(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Threshold value for filtering metrics.
        """
        return pulumi.get(self, "value_threshold")

    @value_threshold.setter
    def value_threshold(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "value_threshold", value)

    @property
    @pulumi.getter(name="waitForCohortWindow")
    def wait_for_cohort_window(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "wait_for_cohort_window")

    @wait_for_cohort_window.setter
    def wait_for_cohort_window(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "wait_for_cohort_window", value)

    @property
    @pulumi.getter(name="winsorizationHigh")
    def winsorization_high(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        High threshold for winsorization; must be between 0 and 1.
        """
        return pulumi.get(self, "winsorization_high")

    @winsorization_high.setter
    def winsorization_high(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "winsorization_high", value)

    @property
    @pulumi.getter(name="winsorizationLow")
    def winsorization_low(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Low threshold for winsorization; must be between 0 and 1.
        """
        return pulumi.get(self, "winsorization_low")

    @winsorization_low.setter
    def winsorization_low(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "winsorization_low", value)


if not MYPY:
    class MetricWarehouseNativeCriteriaArgsDict(TypedDict):
        condition: pulumi.Input[builtins.str]
        """
        sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        """
        type: pulumi.Input[builtins.str]
        """
        Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        """
        column: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional column specifying which data attribute to filter on.
        """
        null_vacuous_override: NotRequired[pulumi.Input[builtins.bool]]
        """
        If true, overrides null values in criterion evaluation.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional array of values for the criterion to match against.
        """
elif False:
    MetricWarehouseNativeCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricWarehouseNativeCriteriaArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 column: Optional[pulumi.Input[builtins.str]] = None,
                 null_vacuous_override: Optional[pulumi.Input[builtins.bool]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] condition: sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        :param pulumi.Input[builtins.str] type: Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        :param pulumi.Input[builtins.str] column: Optional column specifying which data attribute to filter on.
        :param pulumi.Input[builtins.bool] null_vacuous_override: If true, overrides null values in criterion evaluation.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] values: Optional array of values for the criterion to match against.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "type", type)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if null_vacuous_override is not None:
            pulumi.set(__self__, "null_vacuous_override", null_vacuous_override)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[builtins.str]:
        """
        sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional column specifying which data attribute to filter on.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="nullVacuousOverride")
    def null_vacuous_override(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If true, overrides null values in criterion evaluation.
        """
        return pulumi.get(self, "null_vacuous_override")

    @null_vacuous_override.setter
    def null_vacuous_override(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "null_vacuous_override", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional array of values for the criterion to match against.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MetricWarehouseNativeDenominatorCriteriaArgsDict(TypedDict):
        condition: pulumi.Input[builtins.str]
        """
        sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        """
        type: pulumi.Input[builtins.str]
        """
        Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        """
        column: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional column specifying which data attribute to filter on.
        """
        null_vacuous_override: NotRequired[pulumi.Input[builtins.bool]]
        """
        If true, overrides null values in criterion evaluation.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional array of values for the criterion to match against.
        """
elif False:
    MetricWarehouseNativeDenominatorCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricWarehouseNativeDenominatorCriteriaArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 column: Optional[pulumi.Input[builtins.str]] = None,
                 null_vacuous_override: Optional[pulumi.Input[builtins.bool]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] condition: sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        :param pulumi.Input[builtins.str] type: Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        :param pulumi.Input[builtins.str] column: Optional column specifying which data attribute to filter on.
        :param pulumi.Input[builtins.bool] null_vacuous_override: If true, overrides null values in criterion evaluation.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] values: Optional array of values for the criterion to match against.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "type", type)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if null_vacuous_override is not None:
            pulumi.set(__self__, "null_vacuous_override", null_vacuous_override)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[builtins.str]:
        """
        sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional column specifying which data attribute to filter on.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="nullVacuousOverride")
    def null_vacuous_override(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If true, overrides null values in criterion evaluation.
        """
        return pulumi.get(self, "null_vacuous_override")

    @null_vacuous_override.setter
    def null_vacuous_override(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "null_vacuous_override", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional array of values for the criterion to match against.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MetricWarehouseNativeFunnelEventArgsDict(TypedDict):
        criterias: NotRequired[pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeFunnelEventCriteriaArgsDict']]]]
        """
        Optional array of criteria to filter the funnel events, defined by various types and conditions.
        """
        metric_source_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional name of the metric source associated with the funnel event.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional step name for the funnel event, can be null if not specified.
        """
        session_identifier_field: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of column which being used as session identifier. Funnel event with the same metric source
        """
elif False:
    MetricWarehouseNativeFunnelEventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricWarehouseNativeFunnelEventArgs:
    def __init__(__self__, *,
                 criterias: Optional[pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeFunnelEventCriteriaArgs']]]] = None,
                 metric_source_name: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 session_identifier_field: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeFunnelEventCriteriaArgs']]] criterias: Optional array of criteria to filter the funnel events, defined by various types and conditions.
        :param pulumi.Input[builtins.str] metric_source_name: Optional name of the metric source associated with the funnel event.
        :param pulumi.Input[builtins.str] name: Optional step name for the funnel event, can be null if not specified.
        :param pulumi.Input[builtins.str] session_identifier_field: Name of column which being used as session identifier. Funnel event with the same metric source
        """
        if criterias is not None:
            pulumi.set(__self__, "criterias", criterias)
        if metric_source_name is not None:
            pulumi.set(__self__, "metric_source_name", metric_source_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if session_identifier_field is not None:
            pulumi.set(__self__, "session_identifier_field", session_identifier_field)

    @property
    @pulumi.getter
    def criterias(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeFunnelEventCriteriaArgs']]]]:
        """
        Optional array of criteria to filter the funnel events, defined by various types and conditions.
        """
        return pulumi.get(self, "criterias")

    @criterias.setter
    def criterias(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricWarehouseNativeFunnelEventCriteriaArgs']]]]):
        pulumi.set(self, "criterias", value)

    @property
    @pulumi.getter(name="metricSourceName")
    def metric_source_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional name of the metric source associated with the funnel event.
        """
        return pulumi.get(self, "metric_source_name")

    @metric_source_name.setter
    def metric_source_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "metric_source_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional step name for the funnel event, can be null if not specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sessionIdentifierField")
    def session_identifier_field(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of column which being used as session identifier. Funnel event with the same metric source
        """
        return pulumi.get(self, "session_identifier_field")

    @session_identifier_field.setter
    def session_identifier_field(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "session_identifier_field", value)


if not MYPY:
    class MetricWarehouseNativeFunnelEventCriteriaArgsDict(TypedDict):
        condition: pulumi.Input[builtins.str]
        """
        sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        """
        type: pulumi.Input[builtins.str]
        """
        Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        """
        column: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional column specifying which data attribute to filter on.
        """
        null_vacuous_override: NotRequired[pulumi.Input[builtins.bool]]
        """
        If true, overrides null values in criterion evaluation.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional array of values for the criterion to match against.
        """
elif False:
    MetricWarehouseNativeFunnelEventCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricWarehouseNativeFunnelEventCriteriaArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 column: Optional[pulumi.Input[builtins.str]] = None,
                 null_vacuous_override: Optional[pulumi.Input[builtins.bool]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] condition: sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        :param pulumi.Input[builtins.str] type: Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        :param pulumi.Input[builtins.str] column: Optional column specifying which data attribute to filter on.
        :param pulumi.Input[builtins.bool] null_vacuous_override: If true, overrides null values in criterion evaluation.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] values: Optional array of values for the criterion to match against.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "type", type)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if null_vacuous_override is not None:
            pulumi.set(__self__, "null_vacuous_override", null_vacuous_override)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[builtins.str]:
        """
        sql*filter, start*withs, ends*with, and after*exposure are only applicable in Warehouse Native
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional column specifying which data attribute to filter on.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="nullVacuousOverride")
    def null_vacuous_override(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If true, overrides null values in criterion evaluation.
        """
        return pulumi.get(self, "null_vacuous_override")

    @null_vacuous_override.setter
    def null_vacuous_override(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "null_vacuous_override", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional array of values for the criterion to match against.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "values", value)


