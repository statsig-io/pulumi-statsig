// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * This resource allows you to configure experiments for your Statsig project.
 *
 * To learn more about experiments, see [Experiments Documentation](https://docs.statsig.com/experiments-plus/)
 *
 * To learn more about the API powering this resource, see [Experiments API Documentation](https://docs.statsig.com/console-api/experiments)
 */
export class Experiment extends pulumi.CustomResource {
    /**
     * Get an existing Experiment resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ExperimentState, opts?: pulumi.CustomResourceOptions): Experiment {
        return new Experiment(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'statsig:index/experiment:Experiment';

    /**
     * Returns true if the given object is an instance of Experiment.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Experiment {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Experiment.__pulumiType;
    }

    /**
     * Percent of layer allocated to this experiment
     */
    public readonly allocation!: pulumi.Output<number>;
    /**
     * Warehouse Native Only - Allocation duration in days
     */
    public readonly allocationDuration!: pulumi.Output<number>;
    /**
     * Warehouse Native only - end time for analysis only experiments
     */
    public readonly analysisEndTime!: pulumi.Output<string>;
    /**
     * The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
     */
    public readonly analyticsType!: pulumi.Output<string>;
    /**
     * Name of the source experiment for assignment
     */
    public readonly assignmentSourceExperimentName!: pulumi.Output<string>;
    /**
     * Source name of the assignment
     */
    public readonly assignmentSourceName!: pulumi.Output<string>;
    /**
     * Is Benjamini-Hochberg procedure applied per metric?
     */
    public readonly benjaminiHochbergPerMetric!: pulumi.Output<boolean>;
    /**
     * Is Benjamini-Hochberg procedure applied per variant?
     */
    public readonly benjaminiHochbergPerVariant!: pulumi.Output<boolean>;
    /**
     * Is Benjamini-Hochberg procedure applied for primary metrics only?
     */
    public readonly benjaminiPrimaryMetricsOnly!: pulumi.Output<boolean>;
    /**
     * Is Bonferroni correction applied per variant?
     */
    public readonly bonferroniCorrection!: pulumi.Output<boolean>;
    /**
     * Is Bonferroni correction applied per metric?
     */
    public readonly bonferroniCorrectionPerMetric!: pulumi.Output<boolean>;
    /**
     * Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
     */
    public readonly cohortWaitUntilEndToInclude!: pulumi.Output<boolean>;
    /**
     * Warehouse Native Only - Cohorted analysis duration in days
     */
    public readonly cohortedAnalysisDuration!: pulumi.Output<number>;
    /**
     * Warehouse Native Only - Allow cohort metrics to mature after experiment end
     */
    public readonly cohortedMetricsMatureAfterEnd!: pulumi.Output<boolean>;
    /**
     * Optional control group ID
     */
    public readonly controlGroupId!: pulumi.Output<string>;
    /**
     * The email of the creator of this experiment
     */
    public readonly creatorEmail!: pulumi.Output<string>;
    /**
     * The Statsig ID of the creator of this experiment
     */
    public readonly creatorId!: pulumi.Output<string>;
    /**
     * Default error margin used for results
     */
    public readonly defaultConfidenceInterval!: pulumi.Output<string>;
    /**
     * A description of the new experiment
     */
    public readonly description!: pulumi.Output<string>;
    /**
     * How long the experiment is expected to last in days
     */
    public readonly duration!: pulumi.Output<number>;
    /**
     * Fixed analysis duration in days
     */
    public readonly fixedAnalysisDuration!: pulumi.Output<number>;
    /**
     * The test groups for your experiment
     */
    public readonly groups!: pulumi.Output<outputs.ExperimentGroup[]>;
    /**
     * A statement that will be tested by this experiment
     */
    public readonly hypothesis!: pulumi.Output<string>;
    /**
     * The idType the experiment will be performed on
     */
    public readonly idType!: pulumi.Output<string>;
    /**
     * For Warehouse Native
     */
    public readonly isAnalysisOnly!: pulumi.Output<boolean>;
    /**
     * ID of the launched group, null otherwise
     */
    public readonly launchedGroupId!: pulumi.Output<string>;
    /**
     * Which layer to place the experiment into.
     */
    public readonly layerId!: pulumi.Output<string>;
    /**
     * Links to relevant documentation or resources
     */
    public readonly links!: pulumi.Output<outputs.ExperimentLink[]>;
    /**
     * The name of the new experiment
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * Primary metric tags for the experiment
     */
    public readonly primaryMetricTags!: pulumi.Output<string[]>;
    /**
     * Main metrics needed to evaluate your hypothesis
     */
    public readonly primaryMetrics!: pulumi.Output<outputs.ExperimentPrimaryMetric[]>;
    /**
     * Warehouse Native only - UTC hour at which to run scheduled pulse loads
     */
    public readonly scheduledReloadHour!: pulumi.Output<number>;
    /**
     * Warehouse Native only - reload type for scheduled reloads
     */
    public readonly scheduledReloadType!: pulumi.Output<string>;
    /**
     * The secondary ID type for the experiment used in WHN for ID resolution
     */
    public readonly secondaryIdtype!: pulumi.Output<string>;
    /**
     * Secondary metric tags for the experiment
     */
    public readonly secondaryMetricTags!: pulumi.Output<string[]>;
    /**
     * Additional metrics to monitor that might impact the analysis or final decision of the experiment
     */
    public readonly secondaryMetrics!: pulumi.Output<outputs.ExperimentSecondaryMetric[]>;
    /**
     * Apply sequential testing?
     */
    public readonly sequentialTesting!: pulumi.Output<boolean>;
    /**
     * The current status of the experiment
     */
    public readonly status!: pulumi.Output<string>;
    /**
     * Tags associated with the experiment
     */
    public readonly tags!: pulumi.Output<string[]>;
    /**
     * Target apps assigned to this experiment
     */
    public readonly targetApps!: pulumi.Output<string[]>;
    /**
     * Target exposures for the experiment
     */
    public readonly targetExposures!: pulumi.Output<number>;
    /**
     * Restrict your experiment to users passing the selected feature gate
     */
    public readonly targetingGateId!: pulumi.Output<string>;
    /**
     * Enterprise only
     */
    public readonly team!: pulumi.Output<string>;

    /**
     * Create a Experiment resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: ExperimentArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ExperimentArgs | ExperimentState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ExperimentState | undefined;
            resourceInputs["allocation"] = state ? state.allocation : undefined;
            resourceInputs["allocationDuration"] = state ? state.allocationDuration : undefined;
            resourceInputs["analysisEndTime"] = state ? state.analysisEndTime : undefined;
            resourceInputs["analyticsType"] = state ? state.analyticsType : undefined;
            resourceInputs["assignmentSourceExperimentName"] = state ? state.assignmentSourceExperimentName : undefined;
            resourceInputs["assignmentSourceName"] = state ? state.assignmentSourceName : undefined;
            resourceInputs["benjaminiHochbergPerMetric"] = state ? state.benjaminiHochbergPerMetric : undefined;
            resourceInputs["benjaminiHochbergPerVariant"] = state ? state.benjaminiHochbergPerVariant : undefined;
            resourceInputs["benjaminiPrimaryMetricsOnly"] = state ? state.benjaminiPrimaryMetricsOnly : undefined;
            resourceInputs["bonferroniCorrection"] = state ? state.bonferroniCorrection : undefined;
            resourceInputs["bonferroniCorrectionPerMetric"] = state ? state.bonferroniCorrectionPerMetric : undefined;
            resourceInputs["cohortWaitUntilEndToInclude"] = state ? state.cohortWaitUntilEndToInclude : undefined;
            resourceInputs["cohortedAnalysisDuration"] = state ? state.cohortedAnalysisDuration : undefined;
            resourceInputs["cohortedMetricsMatureAfterEnd"] = state ? state.cohortedMetricsMatureAfterEnd : undefined;
            resourceInputs["controlGroupId"] = state ? state.controlGroupId : undefined;
            resourceInputs["creatorEmail"] = state ? state.creatorEmail : undefined;
            resourceInputs["creatorId"] = state ? state.creatorId : undefined;
            resourceInputs["defaultConfidenceInterval"] = state ? state.defaultConfidenceInterval : undefined;
            resourceInputs["description"] = state ? state.description : undefined;
            resourceInputs["duration"] = state ? state.duration : undefined;
            resourceInputs["fixedAnalysisDuration"] = state ? state.fixedAnalysisDuration : undefined;
            resourceInputs["groups"] = state ? state.groups : undefined;
            resourceInputs["hypothesis"] = state ? state.hypothesis : undefined;
            resourceInputs["idType"] = state ? state.idType : undefined;
            resourceInputs["isAnalysisOnly"] = state ? state.isAnalysisOnly : undefined;
            resourceInputs["launchedGroupId"] = state ? state.launchedGroupId : undefined;
            resourceInputs["layerId"] = state ? state.layerId : undefined;
            resourceInputs["links"] = state ? state.links : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["primaryMetricTags"] = state ? state.primaryMetricTags : undefined;
            resourceInputs["primaryMetrics"] = state ? state.primaryMetrics : undefined;
            resourceInputs["scheduledReloadHour"] = state ? state.scheduledReloadHour : undefined;
            resourceInputs["scheduledReloadType"] = state ? state.scheduledReloadType : undefined;
            resourceInputs["secondaryIdtype"] = state ? state.secondaryIdtype : undefined;
            resourceInputs["secondaryMetricTags"] = state ? state.secondaryMetricTags : undefined;
            resourceInputs["secondaryMetrics"] = state ? state.secondaryMetrics : undefined;
            resourceInputs["sequentialTesting"] = state ? state.sequentialTesting : undefined;
            resourceInputs["status"] = state ? state.status : undefined;
            resourceInputs["tags"] = state ? state.tags : undefined;
            resourceInputs["targetApps"] = state ? state.targetApps : undefined;
            resourceInputs["targetExposures"] = state ? state.targetExposures : undefined;
            resourceInputs["targetingGateId"] = state ? state.targetingGateId : undefined;
            resourceInputs["team"] = state ? state.team : undefined;
        } else {
            const args = argsOrState as ExperimentArgs | undefined;
            resourceInputs["allocation"] = args ? args.allocation : undefined;
            resourceInputs["allocationDuration"] = args ? args.allocationDuration : undefined;
            resourceInputs["analysisEndTime"] = args ? args.analysisEndTime : undefined;
            resourceInputs["analyticsType"] = args ? args.analyticsType : undefined;
            resourceInputs["assignmentSourceExperimentName"] = args ? args.assignmentSourceExperimentName : undefined;
            resourceInputs["assignmentSourceName"] = args ? args.assignmentSourceName : undefined;
            resourceInputs["benjaminiHochbergPerMetric"] = args ? args.benjaminiHochbergPerMetric : undefined;
            resourceInputs["benjaminiHochbergPerVariant"] = args ? args.benjaminiHochbergPerVariant : undefined;
            resourceInputs["benjaminiPrimaryMetricsOnly"] = args ? args.benjaminiPrimaryMetricsOnly : undefined;
            resourceInputs["bonferroniCorrection"] = args ? args.bonferroniCorrection : undefined;
            resourceInputs["bonferroniCorrectionPerMetric"] = args ? args.bonferroniCorrectionPerMetric : undefined;
            resourceInputs["cohortWaitUntilEndToInclude"] = args ? args.cohortWaitUntilEndToInclude : undefined;
            resourceInputs["cohortedAnalysisDuration"] = args ? args.cohortedAnalysisDuration : undefined;
            resourceInputs["cohortedMetricsMatureAfterEnd"] = args ? args.cohortedMetricsMatureAfterEnd : undefined;
            resourceInputs["controlGroupId"] = args ? args.controlGroupId : undefined;
            resourceInputs["creatorEmail"] = args ? args.creatorEmail : undefined;
            resourceInputs["creatorId"] = args ? args.creatorId : undefined;
            resourceInputs["defaultConfidenceInterval"] = args ? args.defaultConfidenceInterval : undefined;
            resourceInputs["description"] = args ? args.description : undefined;
            resourceInputs["duration"] = args ? args.duration : undefined;
            resourceInputs["fixedAnalysisDuration"] = args ? args.fixedAnalysisDuration : undefined;
            resourceInputs["groups"] = args ? args.groups : undefined;
            resourceInputs["hypothesis"] = args ? args.hypothesis : undefined;
            resourceInputs["idType"] = args ? args.idType : undefined;
            resourceInputs["isAnalysisOnly"] = args ? args.isAnalysisOnly : undefined;
            resourceInputs["launchedGroupId"] = args ? args.launchedGroupId : undefined;
            resourceInputs["layerId"] = args ? args.layerId : undefined;
            resourceInputs["links"] = args ? args.links : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["primaryMetricTags"] = args ? args.primaryMetricTags : undefined;
            resourceInputs["primaryMetrics"] = args ? args.primaryMetrics : undefined;
            resourceInputs["scheduledReloadHour"] = args ? args.scheduledReloadHour : undefined;
            resourceInputs["scheduledReloadType"] = args ? args.scheduledReloadType : undefined;
            resourceInputs["secondaryIdtype"] = args ? args.secondaryIdtype : undefined;
            resourceInputs["secondaryMetricTags"] = args ? args.secondaryMetricTags : undefined;
            resourceInputs["secondaryMetrics"] = args ? args.secondaryMetrics : undefined;
            resourceInputs["sequentialTesting"] = args ? args.sequentialTesting : undefined;
            resourceInputs["status"] = args ? args.status : undefined;
            resourceInputs["tags"] = args ? args.tags : undefined;
            resourceInputs["targetApps"] = args ? args.targetApps : undefined;
            resourceInputs["targetExposures"] = args ? args.targetExposures : undefined;
            resourceInputs["targetingGateId"] = args ? args.targetingGateId : undefined;
            resourceInputs["team"] = args ? args.team : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Experiment.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Experiment resources.
 */
export interface ExperimentState {
    /**
     * Percent of layer allocated to this experiment
     */
    allocation?: pulumi.Input<number>;
    /**
     * Warehouse Native Only - Allocation duration in days
     */
    allocationDuration?: pulumi.Input<number>;
    /**
     * Warehouse Native only - end time for analysis only experiments
     */
    analysisEndTime?: pulumi.Input<string>;
    /**
     * The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
     */
    analyticsType?: pulumi.Input<string>;
    /**
     * Name of the source experiment for assignment
     */
    assignmentSourceExperimentName?: pulumi.Input<string>;
    /**
     * Source name of the assignment
     */
    assignmentSourceName?: pulumi.Input<string>;
    /**
     * Is Benjamini-Hochberg procedure applied per metric?
     */
    benjaminiHochbergPerMetric?: pulumi.Input<boolean>;
    /**
     * Is Benjamini-Hochberg procedure applied per variant?
     */
    benjaminiHochbergPerVariant?: pulumi.Input<boolean>;
    /**
     * Is Benjamini-Hochberg procedure applied for primary metrics only?
     */
    benjaminiPrimaryMetricsOnly?: pulumi.Input<boolean>;
    /**
     * Is Bonferroni correction applied per variant?
     */
    bonferroniCorrection?: pulumi.Input<boolean>;
    /**
     * Is Bonferroni correction applied per metric?
     */
    bonferroniCorrectionPerMetric?: pulumi.Input<boolean>;
    /**
     * Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
     */
    cohortWaitUntilEndToInclude?: pulumi.Input<boolean>;
    /**
     * Warehouse Native Only - Cohorted analysis duration in days
     */
    cohortedAnalysisDuration?: pulumi.Input<number>;
    /**
     * Warehouse Native Only - Allow cohort metrics to mature after experiment end
     */
    cohortedMetricsMatureAfterEnd?: pulumi.Input<boolean>;
    /**
     * Optional control group ID
     */
    controlGroupId?: pulumi.Input<string>;
    /**
     * The email of the creator of this experiment
     */
    creatorEmail?: pulumi.Input<string>;
    /**
     * The Statsig ID of the creator of this experiment
     */
    creatorId?: pulumi.Input<string>;
    /**
     * Default error margin used for results
     */
    defaultConfidenceInterval?: pulumi.Input<string>;
    /**
     * A description of the new experiment
     */
    description?: pulumi.Input<string>;
    /**
     * How long the experiment is expected to last in days
     */
    duration?: pulumi.Input<number>;
    /**
     * Fixed analysis duration in days
     */
    fixedAnalysisDuration?: pulumi.Input<number>;
    /**
     * The test groups for your experiment
     */
    groups?: pulumi.Input<pulumi.Input<inputs.ExperimentGroup>[]>;
    /**
     * A statement that will be tested by this experiment
     */
    hypothesis?: pulumi.Input<string>;
    /**
     * The idType the experiment will be performed on
     */
    idType?: pulumi.Input<string>;
    /**
     * For Warehouse Native
     */
    isAnalysisOnly?: pulumi.Input<boolean>;
    /**
     * ID of the launched group, null otherwise
     */
    launchedGroupId?: pulumi.Input<string>;
    /**
     * Which layer to place the experiment into.
     */
    layerId?: pulumi.Input<string>;
    /**
     * Links to relevant documentation or resources
     */
    links?: pulumi.Input<pulumi.Input<inputs.ExperimentLink>[]>;
    /**
     * The name of the new experiment
     */
    name?: pulumi.Input<string>;
    /**
     * Primary metric tags for the experiment
     */
    primaryMetricTags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Main metrics needed to evaluate your hypothesis
     */
    primaryMetrics?: pulumi.Input<pulumi.Input<inputs.ExperimentPrimaryMetric>[]>;
    /**
     * Warehouse Native only - UTC hour at which to run scheduled pulse loads
     */
    scheduledReloadHour?: pulumi.Input<number>;
    /**
     * Warehouse Native only - reload type for scheduled reloads
     */
    scheduledReloadType?: pulumi.Input<string>;
    /**
     * The secondary ID type for the experiment used in WHN for ID resolution
     */
    secondaryIdtype?: pulumi.Input<string>;
    /**
     * Secondary metric tags for the experiment
     */
    secondaryMetricTags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Additional metrics to monitor that might impact the analysis or final decision of the experiment
     */
    secondaryMetrics?: pulumi.Input<pulumi.Input<inputs.ExperimentSecondaryMetric>[]>;
    /**
     * Apply sequential testing?
     */
    sequentialTesting?: pulumi.Input<boolean>;
    /**
     * The current status of the experiment
     */
    status?: pulumi.Input<string>;
    /**
     * Tags associated with the experiment
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Target apps assigned to this experiment
     */
    targetApps?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Target exposures for the experiment
     */
    targetExposures?: pulumi.Input<number>;
    /**
     * Restrict your experiment to users passing the selected feature gate
     */
    targetingGateId?: pulumi.Input<string>;
    /**
     * Enterprise only
     */
    team?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a Experiment resource.
 */
export interface ExperimentArgs {
    /**
     * Percent of layer allocated to this experiment
     */
    allocation?: pulumi.Input<number>;
    /**
     * Warehouse Native Only - Allocation duration in days
     */
    allocationDuration?: pulumi.Input<number>;
    /**
     * Warehouse Native only - end time for analysis only experiments
     */
    analysisEndTime?: pulumi.Input<string>;
    /**
     * The mode of analysis for the experiment, e.g frequentist, bayesian, sprt
     */
    analyticsType?: pulumi.Input<string>;
    /**
     * Name of the source experiment for assignment
     */
    assignmentSourceExperimentName?: pulumi.Input<string>;
    /**
     * Source name of the assignment
     */
    assignmentSourceName?: pulumi.Input<string>;
    /**
     * Is Benjamini-Hochberg procedure applied per metric?
     */
    benjaminiHochbergPerMetric?: pulumi.Input<boolean>;
    /**
     * Is Benjamini-Hochberg procedure applied per variant?
     */
    benjaminiHochbergPerVariant?: pulumi.Input<boolean>;
    /**
     * Is Benjamini-Hochberg procedure applied for primary metrics only?
     */
    benjaminiPrimaryMetricsOnly?: pulumi.Input<boolean>;
    /**
     * Is Bonferroni correction applied per variant?
     */
    bonferroniCorrection?: pulumi.Input<boolean>;
    /**
     * Is Bonferroni correction applied per metric?
     */
    bonferroniCorrectionPerMetric?: pulumi.Input<boolean>;
    /**
     * Warehouse Native Only - Whether to filter to units whose experiment cohort analysis duration is complete, if cohortedAnalysisDuration exists
     */
    cohortWaitUntilEndToInclude?: pulumi.Input<boolean>;
    /**
     * Warehouse Native Only - Cohorted analysis duration in days
     */
    cohortedAnalysisDuration?: pulumi.Input<number>;
    /**
     * Warehouse Native Only - Allow cohort metrics to mature after experiment end
     */
    cohortedMetricsMatureAfterEnd?: pulumi.Input<boolean>;
    /**
     * Optional control group ID
     */
    controlGroupId?: pulumi.Input<string>;
    /**
     * The email of the creator of this experiment
     */
    creatorEmail?: pulumi.Input<string>;
    /**
     * The Statsig ID of the creator of this experiment
     */
    creatorId?: pulumi.Input<string>;
    /**
     * Default error margin used for results
     */
    defaultConfidenceInterval?: pulumi.Input<string>;
    /**
     * A description of the new experiment
     */
    description?: pulumi.Input<string>;
    /**
     * How long the experiment is expected to last in days
     */
    duration?: pulumi.Input<number>;
    /**
     * Fixed analysis duration in days
     */
    fixedAnalysisDuration?: pulumi.Input<number>;
    /**
     * The test groups for your experiment
     */
    groups?: pulumi.Input<pulumi.Input<inputs.ExperimentGroup>[]>;
    /**
     * A statement that will be tested by this experiment
     */
    hypothesis?: pulumi.Input<string>;
    /**
     * The idType the experiment will be performed on
     */
    idType?: pulumi.Input<string>;
    /**
     * For Warehouse Native
     */
    isAnalysisOnly?: pulumi.Input<boolean>;
    /**
     * ID of the launched group, null otherwise
     */
    launchedGroupId?: pulumi.Input<string>;
    /**
     * Which layer to place the experiment into.
     */
    layerId?: pulumi.Input<string>;
    /**
     * Links to relevant documentation or resources
     */
    links?: pulumi.Input<pulumi.Input<inputs.ExperimentLink>[]>;
    /**
     * The name of the new experiment
     */
    name?: pulumi.Input<string>;
    /**
     * Primary metric tags for the experiment
     */
    primaryMetricTags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Main metrics needed to evaluate your hypothesis
     */
    primaryMetrics?: pulumi.Input<pulumi.Input<inputs.ExperimentPrimaryMetric>[]>;
    /**
     * Warehouse Native only - UTC hour at which to run scheduled pulse loads
     */
    scheduledReloadHour?: pulumi.Input<number>;
    /**
     * Warehouse Native only - reload type for scheduled reloads
     */
    scheduledReloadType?: pulumi.Input<string>;
    /**
     * The secondary ID type for the experiment used in WHN for ID resolution
     */
    secondaryIdtype?: pulumi.Input<string>;
    /**
     * Secondary metric tags for the experiment
     */
    secondaryMetricTags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Additional metrics to monitor that might impact the analysis or final decision of the experiment
     */
    secondaryMetrics?: pulumi.Input<pulumi.Input<inputs.ExperimentSecondaryMetric>[]>;
    /**
     * Apply sequential testing?
     */
    sequentialTesting?: pulumi.Input<boolean>;
    /**
     * The current status of the experiment
     */
    status?: pulumi.Input<string>;
    /**
     * Tags associated with the experiment
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Target apps assigned to this experiment
     */
    targetApps?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Target exposures for the experiment
     */
    targetExposures?: pulumi.Input<number>;
    /**
     * Restrict your experiment to users passing the selected feature gate
     */
    targetingGateId?: pulumi.Input<string>;
    /**
     * Enterprise only
     */
    team?: pulumi.Input<string>;
}
